---
title: 'NHANES 2017/2018 Study 2'
author: 
  - Theophilus Baidoo^[tbaidoo@iu.edu, Indiana University Bloomington (IUB).]
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output:
  bookdown::pdf_document2:
    fig_caption: true
    latex_engine: xelatex
    number_sections: true
    toc: true
    toc_depth: 4
header-includes:
  - \usepackage{amsmath}
  - \usepackage{amssymb}
  - \usepackage{amsfonts}
  - \usepackage{amsthm}
  - \usepackage{floatrow}
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhf{}
  - \rhead{Theophilus Baidoo}
  - \lhead{Project `r params$proj_number` -- `r params$proj_title`}
  - \cfoot{\thepage}
  - \usepackage{algorithm}
  - \usepackage[noend]{algpseudocode}
geometry: margin = 0.8in
fontsize: 10pt
params:
  proj_number: I
  proj_title: NHANES Study 2
---


```{r, message=FALSE, warning=FALSE}

library(tidyverse)
library(naniar)
library(VIM)
library(DataExplorer)
library(mice)
library(DMwR2)
library(dplyr)
library(ggplot2)
library(gtsummary)
library(gt)
library(mitools)
library(survey)
library(cobalt)
library(MatchIt)
library(tableone)
library(geepack)
library(epiR)
library(tidyverse)
library(fs)
library(tableone)
library(table1)
library(flextable)
library(tableone)
library(dplyr)
library(flextable)
library(officer)
library(tibble)
library(MatchIt)
library(broom)
library(flextable)
library(cobalt)
library(ggplot2)
library(jtools)


set.seed(100)
```


```{r}

data_nhanes <- readRDS("nhanes_cleandata2.rds")
dim(data_nhanes)
names(data_nhanes)
```

```{r}
data_nhanes <- data_nhanes %>%
  rename(Exposure = trouble_sleep) 


data_nhanes <- data_nhanes %>%
  mutate(
    marital_status = case_when(
      marital_status %in% c("Never married", "Divorced", "Living with partner", "Widowed", "Separated") ~ "Not Married",
      marital_status == "Married" ~ "Married",
      marital_status == "Refused" ~ NA_character_,
      TRUE ~ as.character(marital_status)  # preserves existing NA
    ),
    marital_status = factor(marital_status, levels = c("Married", "Not Married"))
  )

data_nhanes <- data_nhanes %>%
  mutate(
    current_smoker = case_when(
      current_smoker %in% c("Every day", "Some days") ~ "Smoker",
      current_smoker == "Not at all" ~ "Non-Smoker",
      TRUE ~ as.character(current_smoker)  # preserves NA
    ),
    current_smoker = factor(current_smoker, levels = c("Smoker", "Non-Smoker"))
  )

data_nhanes <- data_nhanes %>%
  mutate(
    race_ethnicity = case_when(
      race_ethnicity %in% c("Mexican American", "Other Hispanic") ~ "Hispanic",
      race_ethnicity == "Non-Hispanic Black" ~ "Non-Hispanic Black",
      race_ethnicity == "Non-Hispanic White" ~ "Non-Hispanic White",
      race_ethnicity == "Other Race - Including Multi-Racial" ~ "Other",
      TRUE ~ as.character(race_ethnicity)  # preserves NA
    ),
    race_ethnicity = factor(race_ethnicity, levels = c("Non-Hispanic White", "Non-Hispanic Black", "Hispanic", "Other"))
  )

data_nhanes <- data_nhanes %>%
  mutate(
    diabetes = case_when(
      diabetes == "Yes" ~ "Diabetic",
      diabetes %in% c("No", "Borderline") ~ "Not Diabetic",
      TRUE ~ as.character(diabetes)  # preserves NA
    ),
    diabetes = factor(diabetes, levels = c("Diabetic", "Not Diabetic"))
  )


data_nhanes <- data_nhanes %>%
  mutate(
    Obesity = case_when(
      is.na(bmi) ~ NA_character_,  # Preserve missing values
      bmi >= 30 ~ "Obese",
      bmi < 30 ~ "Not Obese"
    ),
    Obesity = factor(Obesity, levels = c("Not Obese", "Obese"))  # Convert to factor
  )


data_nhanes <- data_nhanes %>%
  mutate(
    Age_Group = cut(age, 
      breaks = quantile(age, probs = c(0, 1/3, 2/3, 1), na.rm = TRUE), 
      include.lowest = TRUE, 
      labels = c("18-39", "40-61", "62+"))
  )

data_nhanes <- data_nhanes %>%
  mutate(
    # HDL: Low if <40 (men) or <50 (women)
    hdl = case_when(
      gender == "Male" & hdl < 40 ~ "Low",
      gender == "Female" & hdl < 50 ~ "Low",
      !is.na(hdl) ~ "Normal",
      TRUE ~ NA_character_
    ),
    hdl = factor(hdl, levels = c("Normal", "Low")),

    # LDL: High if >= 130 mg/dL
    ldl = case_when(
      ldl >= 130 ~ "High",
      !is.na(ldl) ~ "Normal",
      TRUE ~ NA_character_
    ),
    ldl = factor(ldl, levels = c("Normal", "High")),

    # Triglycerides: Cap at 1000, then classify
    triglycerides = ifelse(triglycerides > 1000, 1000, triglycerides),
    triglycerides = case_when(
      triglycerides >= 150 ~ "Elevated",
      !is.na(triglycerides) ~ "Normal",
      TRUE ~ NA_character_
    ),
    triglycerides = factor(triglycerides, levels = c("Normal", "Elevated"))
  )


data_nhanes$alcohol_cat <- cut(
  data_nhanes$alcohol_day,
  breaks = c(0, 2, Inf),
  labels = c("1–2/day", "3+/day"),
  right = TRUE
)


data_nhanes <- data_nhanes %>%
  mutate(
    education = case_when(
      education %in% c("Less than 9th grade", 
                       "9-11th grade (Includes 12th grade with no diploma)") ~ "Less than high school",
      education == "High school graduate/GED or equivalent" ~ "High school/GED",
      education == "Some college or AA degree" ~ "Some college",
      education == "College graduate or above" ~ "College graduate",
      TRUE ~ NA_character_  # Keep missing as NA
    ),
    education = factor(education, levels = c(
      "Less than high school", 
      "High school/GED", 
      "Some college", 
      "College graduate"
    ))
  )
data_nhanes <- data_nhanes %>%
  mutate(
    apnea_symptoms = case_when(
      apnea_symptoms == "Never" ~ "No reported apnea symptoms",
      apnea_symptoms %in% c(
        "Rarely - 1-2 nights a week",
        "Occasionally - 3-4 nights a week",
        "Frequently - 5 or more nights a week"
      ) ~ "Reported apnea symptoms",
      TRUE ~ NA_character_
    ),
    apnea_symptoms = factor(
      apnea_symptoms,
      levels = c("No reported apnea symptoms", "Reported apnea symptoms")
    )
  )


data_nhanes <- data_nhanes %>%
  mutate(
    daytime_sleepy = case_when(
      daytime_sleepy == "Never" ~ "Never",
      daytime_sleepy %in% c(
        "Rarely - 1 time a month",
        "Sometimes - 2-4 times a month",
        "Often- 5-15 times a month"
      ) ~ "Occasional",
      daytime_sleepy == "Almost always - 16-30 times a month" ~ "Frequent",
      TRUE ~ NA_character_  # Keep missing as NA
    ),
    daytime_sleepy = factor(daytime_sleepy, levels = c("Never", "Occasional", "Frequent"))
  )
data_nhanes <- data_nhanes %>%
  mutate(
    depression = case_when(
      depression == "Not at all" ~ "None",
      depression == "Several days" ~ "Mild",
      depression %in% c("More than half the days", "Nearly every day") ~ "Moderate/Severe",
      TRUE ~ NA_character_
    ),
    depression = factor(depression, levels = c("None", "Mild", "Moderate/Severe"))
  )
data_nhanes <- data_nhanes %>%
  mutate(
    work_schedule = case_when(
      work_schedule == "Traditional 9 AM to 5 PM day" ~ "Daytime job",
      work_schedule %in% c(
        "Early mornings",
        "Evening or nights",
        "Variable (early mornings, days, and nights)"
      ) ~ "Non-daytime job",
      TRUE ~ NA_character_
    ),
    work_schedule= factor(work_schedule, levels = c("Daytime job", "Non-daytime job"))
  )


data_nhanes <- data_nhanes %>%
  mutate(
    snore = case_when(
      snore == "Frequently - 5 or more nights a week" ~ "Frequent",
      snore %in% c("Occasionally - 3-4 nights a week", "Rarely - 1-2 nights a week") ~ "Occasional",
      snore == "Never" ~ "Never",
      TRUE ~ NA_character_
    ),
    snore = factor(snore, levels = c("Never", "Occasional", "Frequent"))
  )

```


```{r}
data_nhanes$dyslipidemia <- with(data_nhanes, 
  ifelse(ldl == "High" | hdl == "Low" | triglycerides == "Elevated", "Yes",
         ifelse(!is.na(ldl) & !is.na(hdl) & !is.na(triglycerides), "No", NA))
)

data_nhanes$dyslipidemia <- factor(data_nhanes$dyslipidemia, levels = c("No", "Yes"))


data_nhanes$physically_active <- with(data_nhanes, ifelse(
  work_vigorous == "Yes" |
  work_moderate == "Yes" |
  walk_bike == "Yes" |
  leisure_vigorous == "Yes" |
  leisure_moderate == "Yes",
  "Yes",
  ifelse(
    !is.na(work_vigorous) & !is.na(work_moderate) &
    !is.na(walk_bike) & !is.na(leisure_vigorous) & !is.na(leisure_moderate),
    "No", NA)
))

data_nhanes$physically_active <- factor(data_nhanes$physically_active, levels = c("No", "Yes"))


```



```{r}
data_nhanes <- data_nhanes %>% dplyr::select(
   -alcohol_day, -age, -ldl, -hdl, -triglycerides,
  -work_vigorous, -work_moderate, -walk_bike, -leisure_vigorous, -leisure_moderate
)

```




```{r}
n_total <- nrow(data_nhanes)


model1_vars <- c("Obesity", "Exposure", "snore", "Age_Group", "gender", "race_ethnicity", "income_ratio", "education")
n_model1 <- sum(complete.cases(data_nhanes[, model1_vars]))


model2_vars <- c(model1_vars, "physically_active", "sat_fat", "sugar", "alcohol_cat", 
                 "dyslipidemia", "hypertension", "depression", "diabetes")
n_model2 <- sum(complete.cases(data_nhanes[, model2_vars]))


model3_vars <- c(model2_vars, "apnea_symptoms", "sleep_weekday", "sleep_weekend","work_schedule", "daytime_sleepy")
n_model3 <- sum(complete.cases(data_nhanes[, model3_vars]))


cat("Total participants:", n_total, "\n")
cat("Complete cases for Model 1:", n_model1, "\n")
cat("Complete cases for Model 2:", n_model2, "\n")
cat("Complete cases for Model 3:", n_model3, "\n")

```





# Complete Case Analysis for Model 1



```{r}
# All variables across all models
vars_all_models <- c(
  "Obesity", "Exposure",            # Outcome & exposure
  "Age_Group", "gender", "race_ethnicity", "income_ratio", "education", "work_schedule",  # Model 1
  "physically_active", "sat_fat", "sugar","energy_kcal", "alcohol_cat", 
  "dyslipidemia", "hypertension", "depression", "diabetes",                        # Model 2
  "apnea_symptoms","snore", "sleep_weekday", "sleep_weekend", "daytime_sleepy" # Model 3
)

# Complete-case data for all models
complete_cases_all_models2 <- data_nhanes %>%
  drop_na(all_of(vars_all_models))


saveRDS(complete_cases_all_models2, "results/complete_case_all_models2.rds")

```




```{r, include=FALSE}
analysis_vars <- c(
  "SEQN","Obesity", "Exposure",            # Outcome & exposure
  "Age_Group", "gender", "race_ethnicity", "income_ratio", "education", "work_schedule","psu", "stratum","interview_weight",  # Model 1
   "physically_active", "energy_kcal", "sat_fat", "sugar", "alcohol_cat", 
  "dyslipidemia", "hypertension", "depression", "diabetes",                        # Model 2
  "apnea_symptoms","snore", "sleep_weekday", "sleep_weekend", "daytime_sleepy"  # Model 3
)

analysis_data <- complete_cases_all_models2 %>%
  dplyr::select(all_of(analysis_vars))



```



```{r}
# Drop design variables from the display set
vars_display <- setdiff(colnames(analysis_data), c("SEQN","psu", "stratum", "interview_weight"))

# Create table using only the selected variables
table_data <- analysis_data %>%
  dplyr::select(all_of(vars_display))

# Create Table 1
sum_table <- table1(~ . | Exposure, data = table_data)

# Save to Word
t1flex(sum_table) %>%
  save_as_docx(path = "results/table1_complete_cases2.docx")



```

```{r}
sum_table
```



```{r}

mis_df <- data_nhanes %>%
  mutate(
    group = ifelse(complete.cases(across(all_of(vars_display))), "Complete Data", "Incomplete Data")
  )


tab_ <- CreateTableOne(
  vars = vars_display,
  strata = "group",
  data = mis_df,
  test = TRUE,
  addOverall = FALSE
)


mis_sum <- as.data.frame(print(tab_,
                               quote = FALSE,
                               noSpaces = TRUE,
                               printToggle = FALSE)) %>%
  rownames_to_column("Variable")


flextable(mis_sum) %>%
  save_as_docx(path = "results/s1_table2.docx")


```



## Analyzing Complete Case dataset


# Building model 1

```{r}
covars <- intersect(colnames(analysis_data), c("Age_Group", "education", "gender", "race_ethnicity", "income_ratio"))
exposure <- "Exposure"
```


```{r}
library(tableone)
library(ggpubr)

tabUnmatched <- CreateTableOne(vars = covars, strata = exposure, 
                               data = analysis_data, test = FALSE,addOverall = TRUE)

df <- as.data.frame(print(tabUnmatched, smd = TRUE))

df <- ggtexttable(df, 
                  theme = ttheme("blank", padding = unit(c(8, 8), "mm"),
                                 tbody.style = tbody_style(fill="white", 
                                                           fontface = "plain",
                                                           hjust=1, x=1,size = 12,),
                                 rownames.style = rownames_style(
                                   color = "black",
                                   face = "plain"
                                 ),
                                 colnames.style = colnames_style(
                                   hjust=0,
                                   fill="white")))%>%
  tab_add_hline(at.row = 3, row.side = "top", linewidth = 1)%>%
  tab_add_hline(at.row = 1, row.side = "top", linewidth = 1)%>%
  tab_add_hline(at.row = nrow(df), row.side = "bottom", linewidth = 1)


ggsave(filename = "figures/descriptive2.pdf",
       plot = df, dpi = 300, bg = "transparent", 
       device = "pdf",width = 9,height = 12)
```




```{r}

covarss <- intersect(colnames(analysis_data), c("Age_Group", "education", "gender", "race_ethnicity", "income_ratio", "psu", "stratum", "interview_weight"))
exposure <- "Exposure"


ps.formula <- as.formula(paste(exposure, "~", paste(covarss, collapse = " + ")))

# Fit the PS model
ps.fit <- glm(ps.formula, data = analysis_data, family = binomial("logit"))

# Generate propensity scores
analysis_data$ps <- fitted(ps.fit, type = "response")

```


```{r}
# Calculate stabilized weights
analysis_data$sweightt <- with(analysis_data, 
                              ifelse(I(Exposure == "Yes"), 
                                     mean(I(Exposure == "Yes")) / ps, 
                                     (1 - mean(I(Exposure == "Yes"))) / (1 - ps)))

# Truncate extreme weights (1st and 99th percentiles)
analysis_data$sweightt <- with(analysis_data, 
                               pmin(pmax(sweightt, quantile(sweightt, 0.01)), 
                                    quantile(sweightt, 0.99)))



# Summary of stabilized weights
summary(analysis_data$sweightt)

```

```{r}
density.p <- ggdensity(analysis_data, x = "ps", fill = "Exposure", palette = c("#66c2a5", "#fc8d62")) +
  labs(x = "Propensity Scores",fill = "Exposure") +
  theme_classic()+
  theme(legend.position = "inside",
        legend.position.inside =  c(.89, .85),
        legend.background = element_rect(color = "grey", fill = "white"),
        legend.title = element_text(size = 25),
        legend.text = element_text(size = 25),
        legend.key.size = unit(1, "cm"),
        axis.title.x = element_text(size = 30, margin = margin(t = 20)),
        axis.title.y = element_text(size = 30, margin = margin(r = 20)),
        axis.text = element_text(size = 25),
        strip.text = element_text(size = 25),
        plot.title = element_text(size = 35,hjust=0,margin = margin(b = 15)),
        plot.margin = margin(0,0,0,0))
density.p
ggsave(filename = "figures/psplot.pdf", plot = density.p, device = "pdf",
       dpi = 300, width = 15.5, height = 13, units = "in")
```


```{r}
library(tableone)


cov2 <- c("gender", "race_ethnicity", "education", "income_ratio",
         "Age_Group")

design.stab <- svydesign(ids = ~SEQN, weights = ~sweightt, data = analysis_data)


# Create table ensuring proper data type handling
tab.stab2 <- svyCreateTableOne(
  vars = cov2,
  strata = "Exposure",
  data = design.stab,
  test = FALSE
)

# Print with SMD values
print(tab.stab2, smd = TRUE)
```


All SMDs are less than our specified cut-point of 0.2.

```{r}
# Create unweighted Table 1
table_unweighted <- CreateTableOne(vars = covars, strata = exposure, data = analysis_data, test = FALSE)

# Create weighted Table 1
table_weighted <- svyCreateTableOne(vars = covars,
                                    strata = exposure,
                                    data = svydesign(ids = ~1, weights = ~sweightt, data = analysis_data),
                                    test = FALSE)

# Show SMDs
print(table_unweighted, smd = TRUE)
print(table_weighted, smd = TRUE)
```



```{r}

# formula <- Exposure ~ gender + race_ethnicity + education + income_ratio + Age_Group
# 
# label <- c(
#   gender = "Gender",
#   race_ethnicity = "Race/Ethnicity",
#   #marital_status = "Marital Status",
#   education = "Education",
#   income_ratio = "Income Ratio",
#   Age_Group = "Age Group"
#   #work_schedule = "Work Schedule"
# )
# 
# 
# p <- love.plot(formula,
#                weights = analysis_data$sweightt,
#                data = analysis_data,
#                method = "weighting",
#                thresholds = c(m = 0.2),
#                abs = FALSE,
#                shapes = c("circle filled", "triangle filled"),
#                colors = c("orange", "green"),
#                e.names = c("Original", "Weighted (IPW)"),
#                size = 7,
#                binary = "std",
#                continuous = "std",
#                s.d.denom = "pooled",
#                var.names = label)
# 
# 
# p <- p + scale_shape_manual(values = c(4, 2)) +
#   theme(legend.position = "right",
#         legend.position.inside = c(.89, .93),
#         legend.background = element_rect(color = "grey", fill = "white"),
#         legend.title = element_text(size = 25),
#         legend.text = element_text(size = 25),
#         legend.key.size = unit(1, "cm"),
#         axis.title.x = element_text(size = 30, margin = margin(t = 20)),
#         axis.text = element_text(size = 25),
#         strip.text = element_text(size = 25),
#         plot.margin = margin(10, 20, 10, 20)) +
#   labs(title = "")
# 
# # Add coordinate limits here
# #p <- p + coord_cartesian(xlim = c(-1, 1))
# ggsave(filename = "figures/balplot2.pdf", plot = p, device = "pdf",
#        dpi = 300, width = 18, height = 13, units = "in")
# ggsave(
#   filename = "figures/balplot_final.png",
#   plot = p + coord_cartesian(xlim = c(-0.35, 0.35)) +
#          theme(legend.position = "bottom"),
#   width = 8,
#   height = 10,
#   units = "in",
#   dpi = 300
# )

```
```{r}
# If not installed:
# install.packages("cobalt")

library(cobalt)

# Covariate balance before and after weighting
bal <- bal.tab(Exposure ~ Age_Group + education + gender + race_ethnicity + income_ratio,
        data = analysis_data,
        weights = analysis_data$sweightt,
        method = "weighting",
        un = TRUE)
bal$Balance
abs_smd <- bal$Balance[, c("Diff.Un", "Diff.Adj")]
abs_smd <- abs(abs_smd)
colnames(abs_smd) <- c("Abs_SMD_Unweighted", "Abs_SMD_Weighted")

abs_smd


p <- love.plot(bal,
               thresholds = c(m = 0.2),
               abs = FALSE,
               shapes = c("circle filled", "triangle filled"),
               colors = c("orange", "green"),
               e.names = c("Original", "Weighted (IPW)"),
               size = 7,
               binary = "std",
               continuous = "std",
               s.d.denom = "pooled",
               var.names = label)
p <- p + scale_shape_manual(values = c(4, 2)) +
  theme(
    legend.position = "right",
    legend.position.inside = c(.89, .93),
    legend.background = element_rect(color = "grey", fill = "white"),
    legend.title = element_text(size = 25),
    legend.text = element_text(size = 25),
    legend.key.size = unit(1, "cm"),
    axis.title.x = element_text(size = 30, margin = margin(t = 20)),
    axis.text = element_text(size = 25),
    strip.text = element_text(size = 25),
    plot.margin = margin(10, 20, 10, 20)
  ) +
  labs(title = "")

```



```{r}
analysis_data$new.sweightt <- analysis_data$interview_weight * analysis_data$sweightt

w.design.s2 <- svydesign(
  id = ~psu,
  strata = ~stratum,
  weights = ~new.sweightt,
  data = analysis_data,
  nest = TRUE
)

```



# Double Adjusted model 1

```{r}
model.formula <- as.formula(I(Obesity == 'Obese') ~ Exposure + gender + race_ethnicity + 
                             Age_Group + education + income_ratio
                             )
```


```{r}


model.ps2 <- svyglm(model.formula, design = w.design.s2, family = poisson(link = "log"))


summary(model.ps2)
```
```{r}
#summ(model.ps2, exp = TRUE, confint = TRUE, digits = 3)
```
```{r}
PR <- round(exp(model.ps2$coefficients), 2)
PR <- as.data.frame(PR)
CI <- round(exp(confint(model.ps2)), 2)
PR <- cbind(PR, CI)
PR
```


```{r}
library(broom)

tidy(model.ps2, exponentiate = TRUE, conf.int = TRUE)
```




```{r}
# library(kableExtra)
# est <- coef(model.ps2)
# rr <- exp(est)
# 
# 
# ci <- confint(model.ps2)
# ci_exp <- exp(ci)
# 
# 
# coef_summary <- summary(model.ps2)$coefficients
# p_values <- coef_summary[, "Pr(>|t|)"]
# 
# 
# rr_table <- data.frame(
#   Variable = names(rr),
#   Risk_Ratio = round(rr, 3),
#   CI_Lower = round(ci_exp[, 1], 3),
#   CI_Upper = round(ci_exp[, 2], 3),
#   P_Value = format.pval(p_values, digits = 3, eps = 0.001)
# )
# 
# 
# completekable <- rr_table %>%
#   kbl(caption = "Risk Ratios, Confidence Intervals, and P-Values (Survey-Adjusted Poisson Model)",
#       align = "lcccc") %>%
#   kable_classic(full_width = F, html_font = "sans") %>%
#   column_spec(1, bold = TRUE)
# 
# 
# completekable


```



##  Building Model 2



```{r}
covarss <- intersect(colnames(analysis_data), c("Age_Group", "education", "gender", "race_ethnicity", "income_ratio","physically_active", "sat_fat","energy_kcal", "sugar","alcohol_cat","dyslipidemia","hypertension","depression", "diabetes"))
exposure <- "Exposure"
```


```{r}

# library(ggpubr)
# 
# tabUnmatched2 <- CreateTableOne(vars = covarss, strata = exposure, 
#                                data = analysis_data, test = FALSE,addOverall = TRUE)
# 
# df2 <- as.data.frame(print(tabUnmatched2, smd = TRUE))
# 
# df2 <- ggtexttable(df2, 
#                   theme = ttheme("blank", padding = unit(c(8, 8), "mm"),
#                                  tbody.style = tbody_style(fill="white", 
#                                                            fontface = "plain",
#                                                            hjust=1, x=1,size = 12,),
#                                  rownames.style = rownames_style(
#                                    color = "black",
#                                    face = "plain"
#                                  ),
#                                  colnames.style = colnames_style(
#                                    hjust=0,
#                                    fill="white")))%>%
#   tab_add_hline(at.row = 3, row.side = "top", linewidth = 1)%>%
#   tab_add_hline(at.row = 1, row.side = "top", linewidth = 1)%>%
#   tab_add_hline(at.row = nrow(df), row.side = "bottom", linewidth = 1)
# 
# 
# ggsave(filename = "figures/descriptive2.pdf",
#        plot = df2, dpi = 300, bg = "transparent", 
#        device = "pdf",width = 9,height = 12)
```


```{r}

covarsss <- intersect(colnames(analysis_data), c("Age_Group", "education", "gender", "race_ethnicity", "income_ratio","physically_active", "sat_fat", "energy_kcal", "sugar","alcohol_cat","dyslipidemia","hypertension","depression", "diabetes", "psu", "stratum", "interview_weight"))
exposure <- "Exposure"


ps.formula2 <- as.formula(paste(exposure, "~", paste(covarsss, collapse = " + ")))


ps.fit2 <- glm(ps.formula2, data = analysis_data, family = binomial("logit"))


analysis_data$ps2 <- fitted(ps.fit2, type = "response")

```


```{r}

analysis_data$m2.sweightt <- with(analysis_data, 
                              ifelse(I(Exposure == "Yes"), 
                                     mean(I(Exposure == "Yes")) / ps2, 
                                     (1 - mean(I(Exposure == "Yes"))) / (1 - ps2)))


analysis_data$m2.sweightt <- with(analysis_data, 
                               pmin(pmax(m2.sweightt, quantile(m2.sweightt, 0.01)), 
                                    quantile(m2.sweightt, 0.99)))



summary(analysis_data$m2.sweightt)

```

```{r}
density.p2 <- ggdensity(analysis_data, x = "ps2", fill = "Exposure", palette = c("#66c2a5", "#fc8d62")) +
  labs(x = "Propensity Scores",fill = "Exposure") +
  theme_classic()+
  theme(legend.position = "inside",
        legend.position.inside =  c(.89, .85),
        legend.background = element_rect(color = "grey", fill = "white"),
        legend.title = element_text(size = 25),
        legend.text = element_text(size = 25),
        legend.key.size = unit(1, "cm"),
        axis.title.x = element_text(size = 30, margin = margin(t = 20)),
        axis.title.y = element_text(size = 30, margin = margin(r = 20)),
        axis.text = element_text(size = 25),
        strip.text = element_text(size = 25),
        plot.title = element_text(size = 35,hjust=0,margin = margin(b = 15)),
        plot.margin = margin(0,0,0,0))

density.p2
ggsave(filename = "figures/psplot2.pdf", plot = density.p2, device = "pdf",
       dpi = 300, width = 15.5, height = 13, units = "in")
```

```{r}
# library(tableone)
# 
# 
# cov22 <- c("Age_Group", "education", "gender", "race_ethnicity", "income_ratio" ,"physically_active", "sat_fat", "sugar","energy_kcal","alcohol_cat","dyslipidemia","hypertension","depression", "diabetes")
# 
# design.stab2 <- svydesign(ids = ~SEQN, weights = ~m2.sweightt, data = analysis_data)
# 
# 
# 
# tab.stab22 <- svyCreateTableOne(
#   vars = cov22,
#   strata = "Exposure",
#   data = design.stab2,
#   test = FALSE
# )
# 
# 
# print(tab.stab22, smd = TRUE)

```
```{r}

cov22 <- c("Age_Group", "education", "gender", "race_ethnicity", "income_ratio" ,"physically_active", "sat_fat", "sugar","energy_kcal","alcohol_cat","dyslipidemia","hypertension","depression", "diabetes")

# Create unweighted Table 1
table_unweighted2 <- CreateTableOne(vars = cov22, strata = exposure, data = analysis_data, test = FALSE)

# Create weighted Table 1
table_weighted2 <- svyCreateTableOne(vars = cov22,
                                    strata = exposure,
                                    data = svydesign(ids = ~1, weights = ~m2.sweightt, data = analysis_data),
                                    test = FALSE)

# Show SMDs
print(table_unweighted2, smd = TRUE)
print(table_weighted2, smd = TRUE)
```
```{r}
library(cobalt)

# Covariate balance before and after weighting
bal2 <- bal.tab(Exposure ~ Age_Group + education + gender + race_ethnicity + income_ratio + physically_active + sat_fat + sugar + energy_kcal + alcohol_cat + dyslipidemia + hypertension + depression + diabetes,
        data = analysis_data,
        weights = analysis_data$m2.sweightt,
        method = "weighting",
        un = TRUE)
bal2$Balance
abs_smd2 <- bal2$Balance[, c("Diff.Un", "Diff.Adj")]
abs_smd2 <- abs(abs_smd2)
colnames(abs_smd2) <- c("Abs_SMD_Unweighted", "Abs_SMD_Weighted")

abs_smd2


p2 <- love.plot(bal2,
               thresholds = c(m = 0.2),
               abs = FALSE,
               shapes = c("circle filled", "triangle filled"),
               colors = c("orange", "green"),
               e.names = c("Original", "Weighted (IPW)"),
               size = 7,
               binary = "std",
               continuous = "std",
               s.d.denom = "pooled",
               var.names = label)
p2 <- p2 + scale_shape_manual(values = c(4, 2)) +
  theme(
    legend.position = "right",
    legend.position.inside = c(.89, .93),
    legend.background = element_rect(color = "grey", fill = "white"),
    legend.title = element_text(size = 25),
    legend.text = element_text(size = 25),
    legend.key.size = unit(1, "cm"),
    axis.title.x = element_text(size = 30, margin = margin(t = 20)),
    axis.text = element_text(size = 25),
    strip.text = element_text(size = 25),
    plot.margin = margin(10, 20, 10, 20)
  ) +
  labs(title = "")
```


```{r}
# library(cobalt)
# library(ggplot2)
# 
# 
# formula2 <- Exposure ~ gender + race_ethnicity  + education + income_ratio + Age_Group + physically_active + sat_fat + sugar + energy_kcal +  alcohol_cat + dyslipidemia + hypertension + depression + diabetes
# 
# label <- c(
#   gender = "Gender",
#   race_ethnicity = "Race/Ethnicity",
#   #marital_status = "Marital Status",
#   education = "Education",
#   income_ratio = "Income Ratio",
#   Age_Group = "Age Group",
#   #work_schedule = "Work Schedule",
#   #current_smoker = "Current Smoker",
#   physically_active = "Phy.Active",
#   sat_fat = "Saturated Fat",
#   sugar = "Saturated Sugar",
#   alcohol_cat = "alcohol"
# )
# 
# 
# p2 <- love.plot(formula2,
#                weights = analysis_data$m2.sweightt,
#                data = analysis_data,
#                method = "weighting",
#                thresholds = c(m = 0.2),
#                abs = FALSE,
#                shapes = c("circle filled", "triangle filled"),
#                colors = c("orange", "green"),
#                e.names = c("Original", "Weighted (IPW)"),
#                size = 7,
#                binary = "std",
#                continuous = "std",
#                s.d.denom = "pooled",
#                var.names = label)
# 
# p2 <- p2 + scale_shape_manual(values = c(4, 2)) +
#   theme(legend.position = "right",
#         legend.position.inside = c(.89, .93),
#         legend.background = element_rect(color = "grey", fill = "white"),
#         legend.title = element_text(size = 25),
#         legend.text = element_text(size = 25),
#         legend.key.size = unit(1, "cm"),
#         axis.title.x = element_text(size = 30, margin = margin(t = 20)),
#         axis.text = element_text(size = 25),
#         strip.text = element_text(size = 25),
#         plot.margin = margin(10, 20, 10, 20)) +
#   labs(title = "")
# 
# #p2
# # Save plot
# #ggsave(filename = "figures/balplot2.pdf", plot = p2, device = "pdf",
#  #      dpi = 300, width = 18, height = 13, units = "in")

```


```{r}
analysis_data$m2.new.sweightt <- analysis_data$interview_weight * analysis_data$m2.sweightt

w.design.s3 <- svydesign(
  id = ~psu,
  strata = ~stratum,
  weights = ~m2.new.sweightt,
  data = analysis_data,
  nest = TRUE
)

```




```{r}
model.formula2 <- as.formula(I(Obesity == 'Obese') ~ Exposure + gender + race_ethnicity + 
                             Age_Group + education + income_ratio + physically_active + sat_fat + sugar + energy_kcal + alcohol_cat + dyslipidemia + hypertension + depression + diabetes
                             )
```


```{r}


model.ps3 <- svyglm(model.formula2, design = w.design.s3, family = poisson(link = "log"))


summary(model.ps3)
```


```{r}
summary(model.ps3, df.resid = degf(w.design.s3))
```


```{r}

corrected_summary <- summary(model.ps3, df.resid = degf(w.design.s3))


coefs <- coef(corrected_summary)
ses <- sqrt(diag(vcov(model.ps3)))  # std errors
pvals <- coef(summary(model.ps3, df.resid = degf(w.design.s3)))[, 4]  # corrected p-values


results_df <- as.data.frame(coefs)
results_df$RR <- exp(results_df$Estimate)
results_df$CI_lower <- exp(results_df$Estimate - 1.96 * ses)
results_df$CI_upper <- exp(results_df$Estimate + 1.96 * ses)
results_df$p_value <- format.pval(pvals, digits = 3, eps = 0.001)


results_df <- results_df[, c("RR", "CI_lower", "CI_upper", "p_value")]
results_df$Variable <- rownames(coefs)
rownames(results_df) <- NULL

results_df <- results_df[, c("Variable", "RR", "CI_lower", "CI_upper", "p_value")]


print(results_df)



```




# Building model 3



```{r}
covarss2 <- intersect(colnames(analysis_data), c("Age_Group", "education", "gender", "race_ethnicity", "income_ratio","work_schedule","physically_active", "sat_fat", "energy_kcal", "apnea_symptoms", "sugar","alcohol_cat","dyslipidemia","hypertension","depression", "diabetes", "sleep_weekday", "sleep_weekend", "daytime_sleepy"))
exposure <- "Exposure"
```


```{r}
# 
# library(ggpubr)
# 
# tabUnmatched3 <- CreateTableOne(vars = covarss2, strata = exposure, 
#                                data = analysis_data, test = FALSE,addOverall = TRUE)
# 
# df3 <- as.data.frame(print(tabUnmatched3, smd = TRUE))
# 
# df3 <- ggtexttable(df3, 
#                   theme = ttheme("blank", padding = unit(c(8, 8), "mm"),
#                                  tbody.style = tbody_style(fill="white", 
#                                                            fontface = "plain",
#                                                            hjust=1, x=1,size = 12,),
#                                  rownames.style = rownames_style(
#                                    color = "black",
#                                    face = "plain"
#                                  ),
#                                  colnames.style = colnames_style(
#                                    hjust=0,
#                                    fill="white")))%>%
#   tab_add_hline(at.row = 3, row.side = "top", linewidth = 1)%>%
#   tab_add_hline(at.row = 1, row.side = "top", linewidth = 1)%>%
#   tab_add_hline(at.row = nrow(df), row.side = "bottom", linewidth = 1)
# 
# 
# ggsave(filename = "figures/descriptive3.pdf",
#        plot = df3, dpi = 300, bg = "transparent", 
#        device = "pdf",width = 9,height = 12)
```


```{r}

covarsss3 <- intersect(colnames(analysis_data), c("Age_Group", "education", "gender", "race_ethnicity", "income_ratio","work_schedule","physically_active", "sat_fat", "energy_kcal", "apnea_symptoms", "sugar","alcohol_cat","dyslipidemia","hypertension","depression", "diabetes", "sleep_weekday","sleep_weekend", "daytime_sleepy"))
exposure <- "Exposure"


ps.formula3 <- as.formula(paste(exposure, "~", paste(covarsss3, collapse = " + ")))


ps.fit3 <- glm(ps.formula3, data = analysis_data, family = binomial("logit"))


analysis_data$ps3 <- fitted(ps.fit3, type = "response")

```


```{r}

analysis_data$m3.sweightt <- with(analysis_data, 
                              ifelse(I(Exposure == "Yes"), 
                                     mean(I(Exposure == "Yes")) / ps3, 
                                     (1 - mean(I(Exposure == "Yes"))) / (1 - ps3)))


analysis_data$m3.sweightt <- with(analysis_data, 
                               pmin(pmax(m3.sweightt, quantile(m3.sweightt, 0.01)), 
                                    quantile(m3.sweightt, 0.99)))




summary(analysis_data$m3.sweightt)

```

```{r}
density.p3 <- ggdensity(analysis_data, x = "ps3", fill = "Exposure", palette = c("#66c2a5", "#fc8d62")) +
  labs(x = "Propensity Scores",fill = "Exposure") +
  theme_classic()+
  theme(legend.position = "inside",
        legend.position.inside =  c(.89, .85),
        legend.background = element_rect(color = "grey", fill = "white"),
        legend.title = element_text(size = 25),
        legend.text = element_text(size = 25),
        legend.key.size = unit(1, "cm"),
        axis.title.x = element_text(size = 30, margin = margin(t = 20)),
        axis.title.y = element_text(size = 30, margin = margin(r = 20)),
        axis.text = element_text(size = 25),
        strip.text = element_text(size = 25),
        plot.title = element_text(size = 35,hjust=0,margin = margin(b = 15)),
        plot.margin = margin(0,0,0,0))

density.p3
ggsave(filename = "figures/psplot3.pdf", plot = density.p3, device = "pdf",
       dpi = 300, width = 15.5, height = 13, units = "in")
```

```{r}
# library(tableone)
# 
# 
# cov222 <- c("Age_Group", "education", "gender", "race_ethnicity", "income_ratio","work_schedule","physically_active", "sat_fat", "energy_kcal", "apnea_symptoms", "sugar","alcohol_cat","dyslipidemia","hypertension","depression", "diabetes", "sleep_weekday","sleep_weekend", "daytime_sleepy")
# 
# design.stab3 <- svydesign(ids = ~SEQN, weights = ~m3.sweightt, data = analysis_data)
# 
# 
# tab.stab222 <- svyCreateTableOne(
#   vars = cov222,
#   strata = "Exposure",
#   data = design.stab3,
#   test = FALSE
# )
# 
# 
# print(tab.stab222, smd = TRUE)

```

```{r}

cov222 <- c("Age_Group", "education", "gender", "race_ethnicity", "income_ratio","work_schedule","physically_active", "sat_fat", "energy_kcal", "apnea_symptoms", "sugar","alcohol_cat","dyslipidemia","hypertension","depression", "diabetes", "sleep_weekday","sleep_weekend", "daytime_sleepy")

# Create unweighted Table 1
table_unweighted3 <- CreateTableOne(vars = cov222, strata = exposure, data = analysis_data, test = FALSE)

# Create weighted Table 1
table_weighted3 <- svyCreateTableOne(vars = cov222,
                                    strata = exposure,
                                    data = svydesign(ids = ~1, weights = ~~m3.sweightt, data = analysis_data),
                                    test = FALSE)

# Show SMDs
print(table_unweighted3, smd = TRUE)
print(table_weighted3, smd = TRUE)
```
```{r}
library(cobalt)

# Covariate balance before and after weighting
bal3 <- bal.tab(Exposure ~ Age_Group + education + gender + race_ethnicity + income_ratio + physically_active + sat_fat + sugar + energy_kcal + alcohol_cat + dyslipidemia + hypertension + depression + diabetes + apnea_symptoms + sleep_weekday + sleep_weekend + daytime_sleepy,
        data = analysis_data,
        weights = analysis_data$m3.sweightt,
        method = "weighting",
        un = TRUE)
bal3$Balance
abs_smd3 <- bal3$Balance[, c("Diff.Un", "Diff.Adj")]
abs_smd3 <- abs(abs_smd3)
colnames(abs_smd3) <- c("Abs_SMD_Unweighted", "Abs_SMD_Weighted")

abs_smd3


p3 <- love.plot(bal3,
               thresholds = c(m = 0.2),
               abs = FALSE,
               shapes = c("circle filled", "triangle filled"),
               colors = c("orange", "green"),
               e.names = c("Original", "Weighted (IPW)"),
               size = 7,
               binary = "std",
               continuous = "std",
               s.d.denom = "pooled",
               var.names = label)
p3 <- p3 + scale_shape_manual(values = c(4, 2)) +
  theme(
    legend.position = "right",
    legend.position.inside = c(.89, .93),
    legend.background = element_rect(color = "grey", fill = "white"),
    legend.title = element_text(size = 25),
    legend.text = element_text(size = 25),
    legend.key.size = unit(1, "cm"),
    axis.title.x = element_text(size = 30, margin = margin(t = 20)),
    axis.text = element_text(size = 25),
    strip.text = element_text(size = 25),
    plot.margin = margin(10, 20, 10, 20)
  ) +
  labs(title = "")
```


```{r}
# library(cobalt)
# library(ggplot2)
# 
# 
# formula3 <- Exposure ~ gender + race_ethnicity  + education + income_ratio + Age_Group + work_schedule + energy_kcal  + physically_active + sat_fat + sugar + alcohol_cat + dyslipidemia + hypertension + depression + diabetes + apnea_symptoms + sleep_weekday + sleep_weekend 
# 
# label <- c(
#   gender = "Gender",
#   race_ethnicity = "Race/Ethnicity",
#   #marital_status = "Marital Status",
#   education = "Education",
#   income_ratio = "Income Ratio",
#   Age_Group = "Age Group",
#   work_schedule = "Work Schedule",
#   #current_smoker = "Current Smoker",
#   physically_active = "Phy.Active",
#   sat_fat = "Saturated Fat",
#   sugar = "Saturated Sugar",
#   alcohol_cat = "alcohol"
# )
# 
# 
# p3 <- love.plot(formula3,
#                weights = analysis_data$m3.sweightt,
#                data = analysis_data,
#                method = "weighting",
#                thresholds = c(m = 0.2),
#                abs = FALSE,
#                shapes = c("circle filled", "triangle filled"),
#                colors = c("orange", "green"),
#                e.names = c("Original", "Weighted (IPW)"),
#                size = 7,
#                binary = "std",
#                continuous = "std",
#                s.d.denom = "pooled",
#                var.names = label)
# 
# 
# p3 <- p3 + scale_shape_manual(values = c(4, 2)) +
#   theme(legend.position = "right",
#         legend.position.inside = c(.89, .93),
#         legend.background = element_rect(color = "grey", fill = "white"),
#         legend.title = element_text(size = 25),
#         legend.text = element_text(size = 25),
#         legend.key.size = unit(1, "cm"),
#         axis.title.x = element_text(size = 30, margin = margin(t = 20)),
#         axis.text = element_text(size = 25),
#         strip.text = element_text(size = 25),
#         plot.margin = margin(10, 20, 10, 20)) +
#   labs(title = "")
# 
# #p3
# 
# ggsave(filename = "figures/balplot3.pdf", plot = p3, device = "pdf",
#        dpi = 300, width = 18, height = 13, units = "in")

```


```{r}
analysis_data$m3.new.sweightt <- analysis_data$interview_weight * analysis_data$m3.sweightt

w.design.s4 <- svydesign(
  id = ~psu,
  strata = ~stratum,
  weights = ~m3.new.sweightt,
  data = analysis_data,
  nest = TRUE
)

```





```{r}
model.formula3 <- as.formula(I(Obesity == 'Obese') ~ Exposure + gender + race_ethnicity + education + income_ratio + Age_Group + work_schedule + energy_kcal + physically_active + sat_fat + sugar + energy_kcal + alcohol_cat + dyslipidemia + hypertension + depression + diabetes + apnea_symptoms + sleep_weekend + sleep_weekday + daytime_sleepy
                             )
```


```{r}

model.ps4 <- svyglm(model.formula3, design = w.design.s4, family = poisson(link = "log"))


summary(model.ps4)
```


```{r}
#summ(model.ps4, exp = TRUE, confint = TRUE, digits = 3)
```
```{r}
summary(model.ps4, df.resid = degf(w.design.s4))
```


```{r}

corrected_summary <- summary(model.ps4, df.resid = degf(w.design.s4))


coefs <- coef(corrected_summary)
ses <- sqrt(diag(vcov(model.ps4)))  # std errors
pvals <- coef(summary(model.ps4, df.resid = degf(w.design.s4)))[, 4]  # corrected p-values


results_df <- as.data.frame(coefs)
results_df$RR <- exp(results_df$Estimate)
results_df$CI_lower <- exp(results_df$Estimate - 1.96 * ses)
results_df$CI_upper <- exp(results_df$Estimate + 1.96 * ses)
results_df$p_value <- format.pval(pvals, digits = 3, eps = 0.001)


results_df <- results_df[, c("RR", "CI_lower", "CI_upper", "p_value")]
results_df$Variable <- rownames(coefs)
rownames(results_df) <- NULL


results_df <- results_df[, c("Variable", "RR", "CI_lower", "CI_upper", "p_value")]


print(results_df)



```



```{r}
#(p / p2 / p3) + 
 # plot_annotation(tag_levels = 'A', tag_prefix = "(", tag_suffix = ")")



#(p) + plot_annotation(tag_levels = 'A', tag_prefix = "(", tag_suffix = ")")
```






# MICE Imputation

```{r}
mice_nhanes <- data_nhanes[,-c(4,17)]

```



```{r}
library(naniar)
pct_miss_case(mice_nhanes)
plot_missing(mice_nhanes)
```
```{r}

missing_summary <- mice_nhanes %>%
  summarise(across(everything(), ~mean(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "pct_missing") %>%
  mutate(pct_missing = round(pct_missing * 100, 2))  # convert to percentage

# Filter variables with < 5% missingness
low_missing_vars <- missing_summary %>%
  filter(pct_missing < 5)


print(low_missing_vars)

```

```{r}
pct_miss_case(mice_nhanes)
```



```{r}
library(tableone)

# Drop PSU, Stratum, and SEQN
data_subset <- mice_nhanes[ , !(names(mice_nhanes) %in% c("psu", "stratum", "SEQN","interview_weight"))]


sum_table2 <- table1(~ . | Exposure, data = data_subset)

t1flex(sum_table2) %>% 
  save_as_docx(path="results/tablemice1.docx")
sum_table2
```





```{r}
library(gtsummary)
library(dplyr)


all_vars <- c(
  "Exposure", "gender", "race_ethnicity", "income_ratio", 
  "education", "sleep_weekday", "sleep_weekend", "apnea_symptoms", 
  "diabetes", "sat_fat", "sugar", "energy_kcal", "depression", 
  "work_schedule", "hypertension", "Obesity", "Age_Group", "alcohol_cat", 
  "dyslipidemia", "physically_active", "daytime_sleepy"
)

# categorical
cat_vars <- c(
  "Exposure", "gender", "race_ethnicity", "education", 
  "apnea_symptoms", "diabetes", "depression", 
  "work_schedule", "hypertension", "Obesity", "Age_Group", "alcohol_cat", 
  "dyslipidemia", "physically_active", "daytime_sleepy"
)



# Recode as character FIRST, then convert to factor with correct levels
mice_nhanes <- mice_nhanes %>%
  mutate(
    dyslipidemia = factor(as.character(dyslipidemia), levels = c("No", "Yes")),
    hypertension = factor(as.character(hypertension), levels = c("No", "Yes")),
    physically_active = factor(as.character(physically_active), levels = c("No", "Yes")),
    Exposure = factor(as.character(Exposure), levels = c("No", "Yes"))
  )


# Create the summary table
table_nhanes <- mice_nhanes %>%
  dplyr::select(all_of(all_vars)) %>%
  tbl_summary(
    by = Exposure,
    type = list(
    all_continuous() ~ "continuous",
    all_categorical() ~ "categorical"),
    missing = "ifany",
    missing_text = "(Missing)",
    statistic = list(
      all_continuous() ~ "{median} ({p25}, {p75})",
      all_categorical() ~ "{n} ({p}%)"
    ),
    digits = all_continuous() ~ 2
  ) %>%
  add_overall() %>%
  bold_labels()


print(table_nhanes)

```

\footnotesize
\item[1] Values are presented as \textit{n} (\%) for categorical variables and median (Q1, Q3) for continuous variables.
\item[] Missing values for each variable are shown as raw counts.
\item[] This table is based on the analytic sample prior to imputation. A complete-case sample, defined as participants with no missing values on model variables, was used in sensitivity analyses.
\end{TableNotes}

```{r}
library(gtsummary)
library(dplyr)


all_vars <- c(
  "snore", "gender", "race_ethnicity", "income_ratio", 
  "education", "sleep_weekday", "sleep_weekend", "apnea_symptoms", 
  "diabetes", "sat_fat", "sugar", "energy_kcal", "depression", 
  "work_schedule", "hypertension", "Obesity", "Age_Group", "alcohol_cat", 
  "dyslipidemia", "physically_active", "daytime_sleepy"
)

# categorical
cat_vars <- c(
  "snore", "gender", "race_ethnicity", "education", 
  "apnea_symptoms", "diabetes", "depression", 
  "work_schedule", "hypertension", "Obesity", "Age_Group", "alcohol_cat", 
  "dyslipidemia", "physically_active", "daytime_sleepy"
)



# Recode as character FIRST, then convert to factor with correct levels
mice_nhanes <- mice_nhanes %>%
  mutate(
    dyslipidemia = factor(as.character(dyslipidemia), levels = c("No", "Yes")),
    hypertension = factor(as.character(hypertension), levels = c("No", "Yes")),
    physically_active = factor(as.character(physically_active), levels = c("No", "Yes"))
    #Exposure = factor(as.character(Exposure), levels = c("No", "Yes"))
  )


# Create the summary table
table_nhanes2 <- mice_nhanes %>%
  dplyr::select(all_of(all_vars)) %>%
  tbl_summary(
    by = snore,
    type = list(
    all_continuous() ~ "continuous",
    all_categorical() ~ "categorical"),
    missing = "ifany",
    missing_text = "(Missing)",
    statistic = list(
      all_continuous() ~ "{median} ({p25}, {p75})",
      all_categorical() ~ "{n} ({p}%)"
    ),
    digits = all_continuous() ~ 2
  ) %>%
  add_overall() %>%
  bold_labels()


print(table_nhanes2)

```


```{r}
# How many Imputations by Von Hippel
library(howManyImputations)

# 2. Run your pilot imputation (e.g. m0 = 20 as von Hippel recommends)
ini_imp <- mice(mice_nhanes, m = 20, maxit = 5, printFlag = FALSE, seed = 500)

# 3. Fit your substantive model in each imputed set (no survey‐weights here)
pilot_mod <- with(
  data = ini_imp,
  glm(I(Obesity == "Obese") ~ Exposure + gender + race_ethnicity + education + income_ratio + Age_Group + work_schedule + energy_kcal + physically_active + sat_fat + sugar + energy_kcal + alcohol_cat + dyslipidemia + hypertension + depression + diabetes + apnea_symptoms + sleep_weekend + sleep_weekday + daytime_sleepy,
      family = poisson(link = "log"))
)


m_needed <- how_many_imputations(pilot_mod)
print(m_needed)

```
```{r}
imp_init <- mice(mice_nhanes, maxit = 0, print = FALSE)
pred     <- imp_init$pred
meth     <- imp_init$meth     # a named vector of length ncol(data)


# Zero‐out predictors for these variables
for (v in c("SEQN","psu","stratum","interview_weight")) {
  meth[v] <- ""               # do not impute
  pred[,v] <- pred[v,] <- 0   # do not use as predictor
}

# Continuous with predictive mean matching
for (v in c("sat_fat","sugar","energy_kcal","sleep_weekend","income_ratio")) {
  meth[v] <- "pmm"
}

# Binary logistic
for (v in c("hypertension","diabetes","dyslipidemia","alcohol_cat","physically_active")) {
  meth[v] <- "logreg"
}

# Polytomous logistic
for (v in c("snore","apnea_symptoms","education","daytime_sleepy", "depression")) {
  meth[v] <- "polyreg"
}

imputation <- mice(
  data            = mice_nhanes,
  predictorMatrix = pred,
  method          = meth,
  m               = m_needed,    
  maxit           = 10,
  seed            = 123,
  printFlag       = FALSE
)

```





```{r, include=FALSE}
impdata <- mice::complete(imputation, action = "long")

```






```{r, message=FALSE, include=FALSE}


impdata$.id <- NULL
m <- m_needed
set.seed(123)

allImputations <- imputationList(lapply(1:m, 
                                         function(n)
                                           subset(impdata, subset=.imp==n)))

str(allImputations)

```



```{r}

DataExplorer::plot_missing(impdata)
```



Step 2: PS weighting steps 1-3 by DuGoff et al. (2014)
Our next step is to use steps 1-3 of the PS weighting analysis:

Step 2.1: Fit the PS model by considering survey features as covariates.
Step 2.2: Calculate PS weights
Step 2.3: Balance checking using SMD. Consider SMD <0.2 as a good covariate balancing.
Step 2.1: PS model specification 

# Model 1

```{r}
ps.formula <- as.formula(I(Exposure == "Yes") ~ Age_Group + gender + income_ratio +  education + race_ethnicity 
                             + psu + stratum + interview_weight)
```


```{r}
dat.ps <- list(NULL)

m <- m_needed 

# PS weighting on each of the imputed datasets
for (ii in 1:m) {
  # Imputed dataset
  dat.imputed <- subset(impdata, .imp == ii)
  
 
  ps.fit <- glm(ps.formula, data = dat.imputed, family = binomial("logit"))
  dat.imputed$ps <- fitted(ps.fit)
  
  # Stabilized weight
  dat.imputed$sweight <- with(dat.imputed, 
                              ifelse(I(Exposure == "Yes"), 
                                     mean(I(Exposure == "Yes"))/ps, 
                                     (1-mean(I(Exposure == "Yes")))/(1-ps)))

 
  dat.ps[[ii]] <- dat.imputed
}


purrr::map_df(dat.ps, function(df){summary(df$sweight)})
```




# Balance checking for each imputed dataset

```{r, include=FALSE}
tab1m <- list(NULL)
for (ii in 1:m) {
  # PS weighted imputed data
  dat <- dat.ps[[ii]]
  

  vars <- c("Age_Group", "gender", "education", "race_ethnicity", 
            "income_ratio")
  
  # Design with truncated stabilized weight
  wdesign <- svydesign(ids = ~SEQN, weights = ~sweight, data = dat)
  
  
  tab1m[[ii]] <- svyCreateTableOne(vars = vars, strata = "Exposure", data = wdesign,
                                   test = F)
}
print(tab1m, smd = TRUE)
```




```{r}
library(cobalt)
library(dplyr)


balance_formula <- Exposure ~ Age_Group + gender + education + race_ethnicity +
  income_ratio

# Store the SMDs in a list
smd_list <- list()

for (i in 1:m) {
  dat <- dat.ps[[i]]
  
  # Compute balance
  bal <- bal.tab(
    x = balance_formula,
    data = dat,
    weights = dat$sweight,
    method = "weighting",
    estimand = "ATE"
  )
  
  # Extract only the SMDs from the balance table
  smd_vector <- bal$Balance[, "Diff.Adj"]
  names(smd_vector) <- rownames(bal$Balance)
  
  smd_list[[i]] <- smd_vector
}

smd_df <- do.call(rbind, smd_list)  # each row is an imputation

# Summarize across imputations
smd_summary <- data.frame(
  Variable = colnames(smd_df),
  Mean_SMD = apply(smd_df, 2, mean, na.rm = TRUE),
  Max_SMD = apply(smd_df, 2, function(x) max(abs(x), na.rm = TRUE))
)


print(smd_summary)


```

Covariate balance after propensity score weighting was assessed using standardized mean differences (SMDs). For multiply imputed datasets (m = 90), SMDs were computed within each imputation and then summarized across imputations by reporting the mean and maximum SMD per covariate. All covariates used in the propensity score model demonstrated adequate balance, with mean SMDs well below the commonly used threshold of 0.1, indicating good comparability between exposed and unexposed groups after weighting (see Figure X and Table Y).

```{r}
# 1. Combine imputed datasets into one long data frame
dat_combined <- bind_rows(dat.ps, .id = ".imp")  # adds .imp = 1, 2, ...
dat_combined$.imp <- as.integer(dat_combined$.imp)

# 2. Compute balance across imputations with weights
bal2 <- bal.tab(
  Exposure ~ Age_Group + gender + education + race_ethnicity +
    income_ratio,
  data = dat_combined,
  weights = dat_combined$sweight,   # assumes sweight is present in all
  imp = ".imp",                     # imputation ID column
  method = "weighting",
  estimand = "ATE",
  s.d.denom = "pooled",
  m.threshold = 0.2,
  un = TRUE                         # include unadjusted SMDs
)

# 3. Define variable labels for prettier plot axes
var.labels <- c(
  Age_Group = "Age Group",
  gender = "Gender",
  income_ratio = "Income Ratio",
  education = "Education",
  race_ethnicity = "Race/Ethnicity"
  #marital_status = "Marital Status",
  #work_schedule = "Work Schedule"
)

vars_to_show <- names(var.labels)

# 4. Create the directional Love plot with full customization
p.simm2 <- love.plot(
  x = bal2,
  stat = "mean.diffs",
  abs = FALSE,                          # show direction
  stars = "std",                        # interpret as standardized
  thresholds = c(m = 0.2),              # draw vertical threshold
  var.names = var.labels,              # custom labels
  disp.vars = vars_to_show,            # limit to key covariates
  binary = "std",
  continuous = "std",
  s.d.denom = "pooled",
  shapes = c("circle filled", "triangle filled"),
  colors = c("orange", "darkgreen"),
  e.names = c("Unweighted", "Weighted (IPTW)"),
  size = 7,
  disp = "dots"
)
```


```{r}
# 5. Customize plot theme with ggplot2
p.simm2 <- p.simm2 +
  scale_shape_manual(values = c(16, 17)) +
  theme(
    legend.position = "right",
    legend.position.inside = c(.89, .93),
    legend.background = element_rect(color = "grey80", fill = "white"),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    legend.key.size = unit(1, "cm"),
    axis.title.x = element_text(size = 16, margin = margin(t = 20)),
    axis.text = element_text(size = 12),
    strip.text = element_text(size = 14),
    plot.margin = margin(10, 10, 10, 10)
  ) +
  labs(
    title = "Covariate Balance Before and After Weighting",
    x = "Standardized Mean Difference"
  )

# 6. Print the Love plot
#print(p.simm2)

```




## Step 3: Outcome modelling
Our next step is to fit the outcome model on each of the imputed dataset. Note that, we must utilize survey features to correctly estimate the standard error. For this step, we will multiply PS weight and survey weight and create a new weight variable.

3.1 Calculating new weights

```{r}

#m <- length(dat.ps)

# Step 1: Multiply PS weights and survey weights
for (ii in 1:m) {
  dat <- dat.ps[[ii]]
  dat$new_weight <- with(dat, interview_weight * sweight)
  dat.ps[[ii]] <- dat
}

# Step 2: Create survey design for each imputed dataset
survey_designs <- lapply(dat.ps, function(dat) {
  svydesign(
    ids = ~psu,
    strata = ~stratum,
    weights = ~new_weight,
    data = dat,
    nest = TRUE
  )
})


model_formula <- I(Obesity == "Obese") ~ Exposure + gender + race_ethnicity + 
  Age_Group + education + income_ratio


fit_list <- lapply(survey_designs, function(des) {
  svyglm(model_formula, design = des, family = poisson(link = "log"))
})
```


```{r}

pooled <- MIcombine(fit_list)
PR <- round(exp(pooled$coefficients), 2)
PR <- as.data.frame(PR)
CI <- round(exp(confint(pooled)), 2)
PR <- cbind(PR, CI)
PR
```


```{r}

summary(pooled, digits = 4, logeffect = TRUE)
```




```{r}

est <- pooled$coefficients
se <- sqrt(diag(pooled$variance))

RR <- round(exp(est), 3)
CI <- round(exp(confint(pooled)), 3)


z <- est / se
p_vals <- round(2 * pnorm(-abs(z)), 3)


result_table <- data.frame(
  Variable = names(est),
  Risk_Ratio = RR,
  CI_Lower = CI[, 1],
  CI_Upper = CI[, 2],
  P_Value = p_vals,
  row.names = NULL
)

print(result_table)




```

# OR




```{r}
#library(survey)
#library(mice)

#m <- length(allImputations$imputations)

#w.design_mice <- vector("list", m)

#for (ii in 1:m) {
 # this_data <- allImputations$imputations[[ii]]
 # this_data$new_weight <- with(dat, interview_weight * sweight) 
 # w.design_mice[[ii]] <- svydesign(
 #   ids = ~psu,
 #   strata = ~stratum,
  #  weights = ~new_weight,
  #  data = this_data,
 #   nest = TRUE
 # )
#}



#model.ps2 <- vector("list", m)

#for (ii in 1:m) {
#  model.ps2[[ii]] <- svyglm(
 #   I(Obesity == "Obese") ~ Exposure + gender + race_ethnicity + 
 #     Age_Group + education + income_ratio + work_schedule,
 #   design = w.design_mice[[ii]],
 #   family = poisson(link = "log")
 # )
#}


#pooled_mice <- MIcombine(model.ps2)
#summary(pooled_mice, logeffect = TRUE)


```

# or ENDS here - the above


## BONUS using MATCHTHEM

```{r, include=FALSE}
library(mice)
library(MatchThem)
library(cobalt)
library(survey)
library(sandwich)
library(lmtest)
library(mitools)
library(ggplot2)
library(dplyr)

weighted <- weightthem(
  Exposure ~ Age_Group + gender + income_ratio +  education + race_ethnicity 
                             + psu + stratum + interview_weight,
  data = imputation,
  method = "ps",
  estimand = "ATE",
  stabilize = TRUE,
  trim.at = 0.01
)

# covariate balance 
balance <- bal.tab(weighted, un = TRUE, disp.v.ratio = TRUE)
print(balance)

balance_df <- balance$Balance

# Remove rows corresponding to survey design variables
vars_to_remove <- c("psu", "strata", "weight")
clean_balance <- balance_df[!rownames(balance_df) %in% vars_to_remove, ]


print(clean_balance)

# Recreate a filtered copy of the object
library(cobalt)

balance <- bal.tab(weighted, un = TRUE)

# Filter balance table
filtered_balance <- balance
filtered_balance$Balance <- balance$Balance[!rownames(balance$Balance) %in% c("psu_2", "stratum", "interview_weight"), ]
```


```{r, include=FALSE}
# Now plot directly from balance object
p.simm_ <- love.plot(
  x = weighted,
  stat = "mean.diffs",
  stars = "std",
  thresholds = c(m = 0.2),
  abs = FALSE,
  disp.stat = "mean.diffs",
  binary = "std",
  continuous = "std",
  s.d.denom = "pooled",
  shapes = c("circle filled", "triangle filled"),
  colors = c("orange", "green"),
  e.names = c("Unadjusted", "Adjusted"),
  size = 7
)


# Customize the plot with ggplot2
p.simm_ <- p.simm_ + 
  scale_shape_manual(values = c(16, 17)) + 
  theme(
    legend.position = "inside",
    legend.position.inside = c(.89, .93),
    legend.background = element_rect(color = "grey", fill = "white"),
    legend.title = element_text(size = 16),
    legend.text = element_text(size = 14),
    legend.key.size = unit(1, "cm"),
    axis.title.x = element_text(size = 18, margin = margin(t = 20)),
    axis.text = element_text(size = 14),
    strip.text = element_text(size = 16),
    plot.margin = margin(10, 10, 10, 10)
  ) +
  labs(
    title = "Covariate Balance Before and After IPTW",
    x = "Standardized Mean Difference"
  )

print(p.simm_)


imp_data <- complete(weighted, "all")


models <- lapply(imp_data, function(df) {
  print(names(df))
  df$combined_weight <- df$weights * df$interview_weight  # Multiply IPTW by survey weight
  
  design <- svydesign(
    ids = ~psu,
    strata = ~stratum,
    weights = ~combined_weight,
    data = df,
    nest = TRUE
  )
  
  svyglm(I(Obesity == "Obese") ~ Exposure + gender + race_ethnicity + 
      Age_Group + education + income_ratio,
         design = design,
         family = poisson(link = "log"))
})

# Pool results using Rubins rules
pooled_mice <- MIcombine(models)
summary(pooled_mice, logeffect = TRUE)

# Extract coefficients and standard errors
est <- pooled_mice$coefficients
se <- sqrt(diag(pooled_mice$variance))

# Compute Risk Ratios and 95% CI
RR <- round(exp(est), 3)
CI <- round(exp(confint(pooled_mice)), 3)

# Calculate p-values manually (Wald test)
z <- est / se
p_vals <- round(2 * pnorm(-abs(z)), 3)

# Combine into a clean data frame
result_table2 <- data.frame(
  Variable = names(est),
  Risk_Ratio = RR,
  CI_Lower = CI[, 1],
  CI_Upper = CI[, 2],
  P_Value = p_vals,
  row.names = NULL
)

# Print or export
print(result_table2)
```

This gave the results as that of the loop method we used earlier.











## Building MODEL 2 using loop



```{r, include=FALSE}
ps.formula_two <- as.formula(I(Exposure == "Yes") ~ Age_Group + gender + income_ratio +  education + race_ethnicity + physically_active + sat_fat + sugar + energy_kcal +  alcohol_cat + dyslipidemia + hypertension + depression + diabetes + psu + stratum + interview_weight)

dat.ps2 <- list(NULL)



for (ii in 1:m) {

  dat.imputed2 <- subset(impdata, .imp == ii)
  
  
  ps.fit2 <- glm(ps.formula_two, data = dat.imputed2, family = binomial("logit"))
  dat.imputed2$ps <- fitted(ps.fit2)
  
 
  dat.imputed2$sweight2 <- with(dat.imputed2, 
                              ifelse(I(Exposure == "Yes"), 
                                     mean(I(Exposure == "Yes"))/ps, 
                                     (1-mean(I(Exposure == "Yes")))/(1-ps)))

 
  dat.ps2[[ii]] <- dat.imputed2
}


purrr::map_df(dat.ps2, function(df){summary(df$sweight2)})

tab2m <- list(NULL)
for (ii in 1:m) {
  # PS weighted imputed data
  dat2 <- dat.ps2[[ii]]
  
 
  vars <- c("Age_Group", "education", "gender", "race_ethnicity", "income_ratio","physically_active", "sat_fat", "sugar","energy_kcal","alcohol_cat","dyslipidemia","hypertension","depression", "diabetes")
  
  
  wdesign2 <- svydesign(ids = ~SEQN, weights = ~sweight2, data = dat2)
  

  tab2m[[ii]] <- svyCreateTableOne(vars = vars, strata = "Exposure", data = wdesign2,
                                   test = F)
}
print(tab2m, smd = TRUE)
```




```{r}
library(cobalt)
library(dplyr)


balance_formula2 <- Exposure ~ gender + race_ethnicity + education + income_ratio + Age_Group + physically_active + sat_fat + sugar + energy_kcal +  alcohol_cat + dyslipidemia + hypertension + depression + diabetes



smd_list2 <- list()

for (i in 1:m) {
  dat2 <- dat.ps2[[i]]
  
  # Compute balance
  bal2 <- bal.tab(
    x = balance_formula2,
    data = dat2,
    weights = dat2$sweight2,
    method = "weighting",
    estimand = "ATE"
  )
  
  # Extract only the SMDs from the balance table
  smd_vector2 <- bal2$Balance[, "Diff.Adj"]
  names(smd_vector2) <- rownames(bal2$Balance)
  
  smd_list2[[i]] <- smd_vector2
}


smd_df2 <- do.call(rbind, smd_list2)  # each row is an imputation


smd_summary2 <- data.frame(
  Variable = colnames(smd_df2),
  Mean_SMD = apply(smd_df2, 2, mean, na.rm = TRUE),
  Max_SMD = apply(smd_df2, 2, function(x) max(abs(x), na.rm = TRUE))
)


print(smd_summary2)


```



```{r}


dat_combined2 <- bind_rows(dat.ps2, .id = ".imp") 
dat_combined2$.imp <- as.integer(dat_combined2$.imp)


bal2 <- bal.tab(
  Exposure ~ gender + race_ethnicity  + education + income_ratio + Age_Group + physically_active + sat_fat + sugar + energy_kcal +  alcohol_cat + dyslipidemia + hypertension + depression + diabetes,
  data = dat_combined2,
  weights = dat_combined2$sweight2,   
  imp = ".imp",                    
  method = "weighting",
  estimand = "ATE",
  s.d.denom = "pooled",
  m.threshold = 0.2,
  un = TRUE                         
)


var.labels <- c(
  Age_Group = "Age Group",
  gender = "Gender",
  income_ratio = "Income Ratio",
  education = "Education",
  race_ethnicity = "Race/Ethnicity"
  #marital_status = "Marital Status",
  #work_schedule = "Work Schedule"
)

vars_to_show <- names(var.labels)


p.simm2_ <- love.plot(
  x = bal2,
  stat = "mean.diffs",
  abs = FALSE,                          # show direction
  stars = "std",                        # interpret as standardized
  thresholds = c(m = 0.2),              # draw vertical threshold
  var.names = var.labels,              # custom labels
  disp.vars = vars_to_show,            # limit to key covariates
  binary = "std",
  continuous = "std",
  s.d.denom = "pooled",
  shapes = c("circle filled", "triangle filled"),
  colors = c("orange", "darkgreen"),
  e.names = c("Unweighted", "Weighted (IPTW)"),
  size = 7
)


p.simm2_ <- p.simm2_ +
  scale_shape_manual(values = c(16, 17)) +
  theme(
    legend.position = "right",
    legend.position.inside = c(.89, .93),
    legend.background = element_rect(color = "grey80", fill = "white"),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    legend.key.size = unit(1, "cm"),
    axis.title.x = element_text(size = 16, margin = margin(t = 20)),
    axis.text = element_text(size = 12),
    strip.text = element_text(size = 14),
    plot.margin = margin(10, 10, 10, 10)
  ) +
  labs(
    title = "Covariate Balance Before and After Weighting",
    x = "Standardized Mean Difference"
  )


#print(p.simm2_)

```






```{r}


library(survey)
library(mitools)

# Step 1: Apply new_weight2 = interview_weight * sweight2
m <- length(dat.ps2)

for (ii in 1:m) {
  dat2 <- dat.ps2[[ii]]
  dat2$new_weight2 <- with(dat2, interview_weight * sweight2)
  dat.ps2[[ii]] <- dat2
}

# Step 2: Create survey design per imputed dataset
survey_designs2 <- lapply(dat.ps2, function(dat) {
  svydesign(
    ids = ~psu,
    strata = ~stratum,
    weights = ~new_weight2,
    data = dat,
    nest = TRUE
  )
})

# Step 3: Define model
model_formula.2 <- I(Obesity == "Obese") ~ Exposure + gender + race_ethnicity + 
   education + income_ratio + Age_Group  + 
  physically_active + sat_fat + sugar + energy_kcal + 
  alcohol_cat + dyslipidemia + hypertension + depression + diabetes

# Step 4: Fit model across survey designs
fit_list2 <- lapply(survey_designs2, function(des) {
  svyglm(model_formula.2, design = des, family = poisson(link = "log"))
})

# Step 5: Pool results
pooled.two <- MIcombine(fit_list2)
summary(pooled.two, digits = 4, logeffect = TRUE)

# Step 6: Create results table
est <- pooled.two$coefficients
se <- sqrt(diag(pooled.two$variance))

# Risk Ratios and 95% CI
RR <- round(exp(est), 3)
CI <- round(exp(confint(pooled.two)), 3)

# P-values
z <- est / se
p_vals <- round(2 * pnorm(-abs(z)), 3)

# Output table
result_table.two <- data.frame(
  Variable = names(est),
  Risk_Ratio = RR,
  CI_Lower = CI[, 1],
  CI_Upper = CI[, 2],
  P_Value = p_vals,
  row.names = NULL
)

# Print result table
print(result_table.two)


```






## bILDING MODEL 3 using loop



```{r, include=FALSE}
ps.formula_three <- as.formula(I(Exposure == "Yes") ~ Age_Group + gender + income_ratio +  education + race_ethnicity + work_schedule + physically_active + sat_fat + sugar + energy_kcal +  alcohol_cat + dyslipidemia + hypertension + depression + diabetes + sleep_weekday + sleep_weekend + daytime_sleepy + psu + stratum + interview_weight)

dat.ps3 <- list(NULL)



for (ii in 1:m) {
  # Imputed dataset
  dat.imputed3 <- subset(impdata, .imp == ii)
  
  
  ps.fit3 <- glm(ps.formula_three, data = dat.imputed3, family = binomial("logit"))
  dat.imputed3$ps <- fitted(ps.fit3)
  
 
  dat.imputed3$sweight3 <- with(dat.imputed3, 
                              ifelse(I(Exposure == "Yes"), 
                                     mean(I(Exposure == "Yes"))/ps, 
                                     (1-mean(I(Exposure == "Yes")))/(1-ps)))

 
  dat.ps3[[ii]] <- dat.imputed3
}


purrr::map_df(dat.ps3, function(df){summary(df$sweight3)})

tab3m <- list(NULL)
for (ii in 1:m) {
 
  dat3 <- dat.ps3[[ii]]
  

  vars <- c("Age_Group", "education", "gender", "race_ethnicity", "income_ratio","work_schedule", "physically_active", "sat_fat", "energy_kcal", "apnea_symptoms", "sugar","alcohol_cat","dyslipidemia","hypertension","depression", "diabetes", "sleep_weekday","sleep_weekend", "daytime_sleepy")
  

  wdesign3 <- svydesign(ids = ~SEQN, weights = ~sweight3, data = dat3)
  
  
  tab3m[[ii]] <- svyCreateTableOne(vars = vars, strata = "Exposure", data = wdesign3,
                                   test = F)
}
print(tab3m, smd = TRUE)
```




```{r}



balance_formula3 <- Exposure ~ gender + race_ethnicity + education + income_ratio + Age_Group + work_schedule + physically_active + sat_fat + sugar + energy_kcal +  alcohol_cat + dyslipidemia + hypertension + depression + diabetes + sleep_weekday + sleep_weekend + daytime_sleepy



smd_list3 <- list()

for (i in 1:m) {
  dat3 <- dat.ps3[[i]]
  
  
  bal3 <- bal.tab(
    x = balance_formula3,
    data = dat3,
    weights = dat3$sweight3,
    method = "weighting",
    estimand = "ATE"
  )
  
 
  smd_vector3 <- bal3$Balance[, "Diff.Adj"]
  names(smd_vector3) <- rownames(bal3$Balance)
  
  smd_list3[[i]] <- smd_vector3
}


smd_df3 <- do.call(rbind, smd_list3)  # each row is an imputation


smd_summary3 <- data.frame(
  Variable = colnames(smd_df3),
  Mean_SMD = apply(smd_df3, 2, mean, na.rm = TRUE),
  Max_SMD = apply(smd_df3, 2, function(x) max(abs(x), na.rm = TRUE))
)


print(smd_summary3)


```



```{r}


dat_combined3 <- bind_rows(dat.ps3, .id = ".imp") 
dat_combined3$.imp <- as.integer(dat_combined3$.imp)


bal3 <- bal.tab(
  Exposure ~ gender + race_ethnicity + education + income_ratio + Age_Group + work_schedule + physically_active + sat_fat + sugar + energy_kcal +  alcohol_cat + dyslipidemia + hypertension + depression + diabetes + sleep_weekday + sleep_weekend + daytime_sleepy,
  data = dat_combined3,
  weights = dat_combined3$sweight3,   
  imp = ".imp",                    
  method = "weighting",
  estimand = "ATE",
  s.d.denom = "pooled",
  m.threshold = 0.2,
  un = TRUE                         
)


var.labels <- c(
  Age_Group = "Age Group",
  gender = "Gender",
  income_ratio = "Income Ratio",
  education = "Education",
  race_ethnicity = "Race/Ethnicity",
  #marital_status = "Marital Status",
  work_schedule = "Work Schedule"
)

vars_to_show <- names(var.labels)


p.simm4_ <- love.plot(
  x = bal3,
  stat = "mean.diffs",
  abs = FALSE,                          # show direction
  stars = "std",                        # interpret as standardized
  thresholds = c(m = 0.2),              # draw vertical threshold
  var.names = var.labels,              # custom labels
  disp.vars = vars_to_show,            # limit to key covariates
  binary = "std",
  continuous = "std",
  s.d.denom = "pooled",
  shapes = c("circle filled", "triangle filled"),
  colors = c("orange", "darkgreen"),
  e.names = c("Unweighted", "Weighted (IPTW)"),
  size = 7
)


p.simm4_ <- p.simm4_ +
  scale_shape_manual(values = c(16, 17)) +
  theme(
    legend.position = "right",
    legend.position.inside = c(.89, .93),
    legend.background = element_rect(color = "grey80", fill = "white"),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    legend.key.size = unit(1, "cm"),
    axis.title.x = element_text(size = 16, margin = margin(t = 20)),
    axis.text = element_text(size = 12),
    strip.text = element_text(size = 14),
    plot.margin = margin(10, 10, 10, 10)
  ) +
  labs(
    title = "Covariate Balance Before and After Weighting",
    x = "Standardized Mean Difference Model 3"
  )


#print(p.simm4_)

```


```{r}
library(survey)
library(mitools)


#m <- length(dat.ps3)

for (ii in 1:m) {
  dat3 <- dat.ps3[[ii]]
  dat3$new_weight3 <- with(dat3, interview_weight * sweight3)
  dat.ps3[[ii]] <- dat3
}


survey_designs3 <- lapply(dat.ps3, function(dat) {
  svydesign(
    ids = ~psu,
    strata = ~stratum,
    weights = ~new_weight3,
    data = dat,
    nest = TRUE
  )
})


model_formula.3 <- I(Obesity == "Obese") ~ Exposure + gender + race_ethnicity +
  education + income_ratio + Age_Group + work_schedule + physically_active + sat_fat + sugar + energy_kcal +  
  alcohol_cat + dyslipidemia + hypertension + depression + diabetes + 
  sleep_weekday + sleep_weekend + daytime_sleepy


fit_list3 <- lapply(survey_designs3, function(des) {
  svyglm(model_formula.3, design = des, family = poisson(link = "log"))
})


pooled.three <- MIcombine(fit_list3)
summary(pooled.three, digits = 4, logeffect = TRUE)


est <- pooled.three$coefficients
se <- sqrt(diag(pooled.three$variance))

RR <- round(exp(est), 3)
CI <- round(exp(confint(pooled.three)), 3)

z <- est / se
p_vals <- round(2 * pnorm(-abs(z)), 3)

result_table.three <- data.frame(
  Variable = names(est),
  Risk_Ratio = RR,
  CI_Lower = CI[, 1],
  CI_Upper = CI[, 2],
  P_Value = p_vals,
  row.names = NULL
)


print(result_table.three)

```




################# Restricted Cubic Splines #########

## Complete Case for model 1




```{r}
#library(plotRCS)
```

```{r}
#library(rms)

#mod5a_rcs <- lm(bmi ~ rcs(sleep_weekday, 3), data = analysis_data)
#mod5b_rcs <- lm(bmi ~ rcs(sleep_weekday, 4), data = analysis_data)
#mod5c_rcs <- lm(bmi ~ rcs(sleep_weekday, 5), data = analysis_data)
```


```{r}
#mod5a.aug <- augment(mod5a_rcs, analysis_data)

#mod5b.aug <- augment(mod5b_rcs, analysis_data)

#mod5c.aug <- augment(mod5c_rcs, analysis_data)
```


```{r}
#library(patchwork)

#p2 <- ggplot(analysis_data, aes(x = sleep_weekday, y = bmi)) +
#    geom_point() +
 #   geom_smooth(method = "loess", col = "purple", se = F) +
 #   labs(title = "Loess Smooth") +
 #   theme_bw()

#p3 <- ggplot(mod5a.aug, aes(x = sleep_weekday, y = bmi)) +
#    geom_point() +
#    geom_line(aes(x = sleep_weekday, y = .fitted), 
#              col = "blue", size = 1.25) +
 #   labs(title = "RCS, 3 knots") +
#    theme_bw()

#p4 <- ggplot(mod5b.aug, aes(x = sleep_weekday, y = bmi)) +
  #  geom_point() +
  #  geom_line(aes(x = sleep_weekday, y = .fitted), 
   #           col = "black", size = 1.25) +
   # labs(title = "RCS, 4 knots") +
   # theme_bw()

#p5 <- ggplot(mod5c.aug, aes(x = sleep_weekday, y = bmi)) +
   # geom_point() +
   # geom_line(aes(x = sleep_weekday, y = .fitted), 
   #           col = "red", size = 1.25) +
   # labs(title = "RCS, 5 knots") +
    #theme_bw()

#(p2 + p3) / (p4 + p5)
```

```{r}
#anova(mod5a_rcs, mod5b_rcs, mod5c_rcs)
```

```{r}
# go back to a single 3‐knot model:
#library(rms)
#dd <- datadist(analysis_data2)        # required by rms
#options(datadist="dd")

#mod3 <- ols(bmi ~ rcs(sleep_weekday, 3), data=analysis_data)
#anova(mod3)

```

```{r}
#library(survey)
#library(rms)

# 1) Your survey design
#w.design.s2 <- svydesign(
#  id      = ~psu,
 # strata  = ~stratum,
 # weights = ~new.sweightt,
 # data    = analysis_data,
 # nest    = TRUE
#)

# 2) Pick 3 Harrell‐style knots at the 10th, 50th, 90th percentiles:
#knots <- with(analysis_data,
  #            quantile(sleep_weekday,
  #                     probs   = c(0.10, 0.50, 0.90),
  #                    na.rm   = TRUE))

# 3) Build the spline basis; figure out how many columns you get, then name them
#spline_mat <- rcspline.eval(analysis_data$sleep_weekday,
        #                    knots = knots,
         #                   inclx = TRUE)

# check
#ncol(spline_mat)  
#> [1] 2

# now assign exactly two names: the first is the “linear” x,
# the second is the single non-linear basis
#colnames(spline_mat) <- c("sleep_lin", "sleep_s2")
```


```{r}
#analysis_data <- cbind(analysis_data, spline_mat)
```

```{r}
# 0) Make sure your data frame has the numeric outcome
#analysis_data$Obesity_binary <- ifelse(analysis_data$Obesity == "Obese", 1, 0)

```

```{r}
#w.design.s2 <- svydesign(
 # id      = ~psu,
 # strata  = ~stratum,
 # weights = ~new.sweightt,
 # data    = analysis_data,    # this data frame contains sleep_lin & sleep_s2
 # nest    = TRUE
#)

# 5) Fit the weighted “modified Poisson” (i.e. log‐link, robust SEs) for obesity
#poiss_spl <- svyglm(Obesity_binary ~ sleep_lin + sleep_s2
                #                   + Age_Group + gender + race_ethnicity + income_ratio + education,
                  #  design = w.design.s2,
                   # family = poisson(link = "log"))

#summary(poiss_spl)

# 6) Test for non-linearity: are the extra spline terms jointly ≠0?
#regTermTest(poiss_spl, ~sleep_s2 + sleep_s3)

```



```{r}
#library(ggplot2)
#library(rms)        # for rcspline.eval
#library(survey)    # for regTermTest

# --- 1) Build a grid of sleep values ------------------------------------------------
#newdat <- data.frame(
  #sleep_weekday = seq(
  #  from = min(analysis_data$sleep_weekday, na.rm=TRUE),
   # to   = max(analysis_data$sleep_weekday, na.rm=TRUE),
    #by   = 0.25
  #)
#)

# # --- 2) Re-create the same 3-knot spline basis ------------------------------------
# bs2 <- rcspline.eval(newdat$sleep_weekday, knots = knots, inclx = TRUE)
# colnames(bs2) <- c("sleep_lin", "sleep_s2")
# newdat <- cbind(newdat, bs2)
# 
# # --- 3) Set covariates to reference/mean levels ------------------------------------
# newdat$Age_Group      <- "18-39"         # change to your chosen ref
# newdat$gender         <- "Female"
# newdat$race_ethnicity <- "Non-Hispanic White"
# newdat$income_ratio   <- median(analysis_data$income_ratio, na.rm=TRUE)
# newdat$education      <- "College graduate"
```


```{r}
# # 4) Get predictions (link scale) as svystat
# pred <- predict(poiss_spl,
#                 newdata = newdat,
#                 type    = "link",
#                 se.fit  = TRUE)
# 
# #  └─ extract fit & SE from the svystat object:
# eta    <- as.numeric(pred)                    # the fitted values
# se_eta <- sqrt(attr(pred, "var"))             # the variances → SDs
# 
# # 5) Transform to PR and CIs
# newdat$PR    <- exp(eta)
# newdat$PR_lo <- exp(eta - 1.96 * se_eta)
# newdat$PR_hi <- exp(eta + 1.96 * se_eta)
```


```{r}
# # --- 5) Grab the non-linearity p-value ---------------------------------------------
# p_nl <- regTermTest(poiss_spl, ~sleep_s2)$p
# p_text <- paste0("P for non-linearity = ", signif(p_nl, 3))
# 
# # --- 6) Plot ------------------------------------------------------------------------
# ggplot(newdat, aes(x = sleep_weekday, y = PR)) +
#   geom_line() +
#   geom_ribbon(aes(ymin = PR_lo, ymax = PR_hi), alpha = 0.2) +
#   annotate(
#     "text",
#     x = max(newdat$sleep_weekday),
#     y = max(newdat$PR_hi),
#     label = p_text,
#     hjust = 1,
#     vjust = 1,
#     size = 4
#   ) +
#   labs(
#     x = "Weekday Sleep (hours)",
#     y = "Adjusted Prevalence Ratio\n(vs reference sleep)"
#   ) +
#   theme_bw()
```

######with segmented
```{r}
# library(segmented)
# library(boot)
# 
# # 7) Fit an unweighted Poisson first, to find a candidate breakpoint
# glm0 <- glm(Obesity_binary ~ sleep_weekday 
#                         + Age_Group + gender + race_ethnicity 
#                         + income_ratio + education,
#             family = poisson(link="log"),
#             data   = analysis_data)
# 
# # initialize segmented at, say, 6 h sleep
# seg0 <- segmented(glm0, seg.Z=~sleep_weekday, psi=list(sleep_weekday=6))
# summary(seg0)
```


```{r}
# # extract estimated breakpoint
# bp <- seg0$psi[1, "Est."]
# 
# # extract pre- and post-breakpoint slopes
# s1 <- slope(seg0)$sleep_weekday[1]   # slope before the breakpoint
# s2 <- slope(seg0)$sleep_weekday[2]   # slope after the breakpoint

```


```{r}
# # 8) Bootstrap the breakpoint (and slopes) in the unweighted data
# boot_fn <- function(data, i){
#   d <- data[i, ]
#   m <- glm(Obesity_binary ~ sleep_weekday 
#                      + Age_Group + gender + race_ethnicity 
#                      + income_ratio + education,
#            family = poisson(link="log"),
#            data   = d)
# 
#   sg <- try(segmented(m, seg.Z = ~sleep_weekday, psi = list(sleep_weekday = bp)), silent=TRUE)
#   if (inherits(sg, "try-error")) return(c(NA, NA, NA))
# 
#   # Extract with numeric row index and exact column name "Est."
#   c(
#     bp = sg$psi[1, "Est."],
#     s1 = slope(sg)$sleep_weekday[1],
#     s2 = slope(sg)$sleep_weekday[2]
#   )
# }
# 
# set.seed(2025)
# boot_res <- boot(analysis_data, statistic = boot_fn, R = 5)
# ```
# 
# 
# ```{r}
# # bootstrap CIs for the breakpoint
# ci_bp <- boot.ci(boot_res, type="perc", index=1)$percent[4:5]
# ci_s1 <- boot.ci(boot_res, type="perc", index=2)$percent[4:5]
# ci_s2 <- boot.ci(boot_res, type="perc", index=3)$percent[4:5]

# 9) Now re-fit the survey‐weighted segmented model,
#    using the estimated bp as a known cutpoint:
# analysis_data$piece1 <- pmin(analysis_data$sleep_weekday, bp)
# analysis_data$piece2 <- pmax(analysis_data$sleep_weekday - bp, 0)
# 
# w.design.s2 <- svydesign(
#   id      = ~psu,
#   strata  = ~stratum,
#   weights = ~new.sweightt,
#   data    = analysis_data,
#   nest    = TRUE
# )
# 
# seg_svy <- svyglm(Obesity_binary ~ piece1 + piece2
#                            + Age_Group + gender + race_ethnicity
#                            + income_ratio + education,
#                   design = w.design.s2,
#                   family = quasipoisson(link="log"))
# summary(seg_svy)
# ```
# 
# 
# ```{r}
# # 10a) Set covariates in plot_df to reference/means:
# plot_df$Age_Group      <- "18-39"         # or whatever your baseline level is
# plot_df$gender         <- "Female"
# plot_df$race_ethnicity <- "Non-Hispanic White"
# plot_df$income_ratio   <- median(analysis_data$income_ratio, na.rm=TRUE)
# plot_df$education      <- "College graduate"
# 
# # 10b) Now predict (response scale) with SEs:
# pred_svy <- predict(seg_svy,
#                     newdata = plot_df,
#                     type    = "response",
#                     se.fit  = TRUE)
# 
# # 1) Extract fitted values & SEs from the svystat object
# fitted_vals <- as.numeric(pred_svy)         # the predicted prevalence
# se_vals     <- sqrt(attr(pred_svy, "var"))  # sqrt of the variances
# 
# # 2) Build your PR and CIs
# plot_df$PR    <- fitted_vals
# plot_df$PR_lo <- fitted_vals - 1.96 * se_vals
# plot_df$PR_hi <- fitted_vals + 1.96 * se_vals
# 
# # 3) Now plot as before
# library(ggplot2)
# ggplot(plot_df, aes(x = sleep_weekday, y = PR)) +
#   geom_line() +
#   geom_ribbon(aes(ymin = PR_lo, ymax = PR_hi), alpha = 0.2) +
#   geom_vline(xintercept = bp, linetype = "dashed") +
#   annotate("text",
#            x     = bp,
#            y     = max(plot_df$PR_hi),
#            label = sprintf("BP = %.2f (%.2f–%.2f)", bp, ci_bp[1], ci_bp[2]),
#            hjust = -0.1, vjust = 1) +
#   labs(x = "Weekday Sleep (hours)",
#        y = "Adjusted Prevalence Ratio",
#        title = "Survey‐Weighted Piecewise Linear Poisson\nwith Bootstrap CI on Breakpoint") +
#   theme_bw()

```

We modeled obesity with a survey‐weighted modified Poisson, first testing non‐linearity via restricted cubic splines (Wald test).

We then fit a piecewise‐linear Poisson to estimate a single inflection point using the segmented package (Davies’ test for slope change), and obtained 95 % CIs for the breakpoint by bootstrap resampling (R=1000).














































############################################################################

# ```{r}
# # RCS curves for a logistic regression model
# rcsplot(data = complete_data,
#         outcome = "Obesity",
#         exposure = "sleep_weekday",
#         covariates = c("Age_Group", "gender", "race_ethnicity", "income_ratio","education"))
# ```
# 
# 
# 
# ```{r}
# library(survey)
# 
# nhanes_design <- svydesign(
#   ids = ~psu,
#   strata = ~stratum,
#   weights = ~interview_weight,
#   data = complete_data,
#   nest = TRUE
# )
# 
# ```
# 
# 
# ```{r}
# library(splines)
# 
# # Modified Poisson with spline
# fit_rcs <- svyglm(
#   Obesity ~ ns(sleep_weekday, df = 4) + Age_Group + gender + race_ethnicity + income_ratio + education,
#   design = nhanes_design,
#   family = poisson(link = "log")
# )
# 
# # Linear (non-spline) model for LRT comparison
# fit_lm <- svyglm(
#   Obesity ~ sleep_weekday + Age_Group + gender + race_ethnicity + income_ratio + education,
#   design = nhanes_design,
#   family = poisson(link = "log")
# )
# 
# ```
# 
# 
# ```{r}
# # Manually compute LRT
# lr_stat <- fit_lm$deviance - fit_rcs$deviance
# df_diff <- fit_lm$df.residual - fit_rcs$df.residual
# pval_nonlin <- pchisq(lr_stat, df = df_diff, lower.tail = FALSE)
# 
# ```
# 
# ```{r}
# library(segmented)
# 
# # Fit unweighted model just to estimate breakpoint
# glm_mod <- glm(
#   Obesity ~ sleep_weekday + Age_Group + gender + race_ethnicity + income_ratio + education,
#   data = complete_data,
#   family = poisson(link = "log")
# )
# 
# # Estimate segmented model (1 breakpoint)
# seg_fit <- segmented(glm_mod, seg.Z = ~ sleep_weekday, npsi = 1)
# breakpoint <- seg_fit$psi[1, "Est."]
# 
# ```
# 
# ```{r}
# library(boot)
# 
# get_breakpoint <- function(data, indices) {
#   d <- data[indices, ]
#   mod <- glm(Obesity ~ sleep_weekday + Age_Group + gender + race_ethnicity +
#                income_ratio + education, data = d, family = poisson(link = "log"))
#   
#   seg_mod <- tryCatch(segmented(mod, seg.Z = ~ sleep_weekday, npsi = 1),
#                       error = function(e) return(NA))
#   
#   if (is.na(seg_mod)[1]) return(NA)
#   return(seg_mod$psi[1, "Est."])
# }
# 
# set.seed(123)
# boot_out <- boot(data = complete_data, statistic = get_breakpoint, R = 5)
# boot_ci <- boot.ci(boot_out, type = "perc")
# inflection_CI <- round(boot_ci$percent[4:5], 2)
# 
# ```
# ```{r}
# # Create new data for prediction grid
# mean_covariates <- complete_data %>%
#   summarise(across(c(income_ratio), ~mean(.x, na.rm = TRUE))) %>%
#   mutate(Age_Group = "40-61", gender = "Female", race_ethnicity = "Non-Hispanic White", education = "College graduate")
# 
# grid <- data.frame(sleep_weekday = seq(3, 11, 0.1)) %>%
#   cbind(mean_covariates[rep(1, nrow(.)), ])
# 
# # Predict log(PR) from svyglm
# pred_log <- predict(fit_rcs, newdata = grid, type = "link", se.fit = TRUE)
# 
# # Extract log predictions
# grid$log_fit <- as.numeric(pred_log)
# 
# # Extract standard errors
# grid$se <- sqrt(attr(pred_log, "var"))
# 
# # Transform to prevalence ratios (PR)
# grid$fit <- exp(grid$log_fit)
# grid$lower <- exp(grid$log_fit - 1.96 * grid$se)
# grid$upper <- exp(grid$log_fit + 1.96 * grid$se)
# 
# # Normalize to reference (closest to 7 hours)
# ref_index <- which.min(abs(grid$sleep_weekday - 7))
# ref_fit <- grid$fit[ref_index]
# 
# grid$PR <- grid$fit / ref_fit
# grid$lower <- grid$lower / ref_fit
# grid$upper <- grid$upper / ref_fit
# 
# 
# ```
# 
# 
# ```{r}
# # Set automatic reference point — where sleep_weekday is closest to 7
# ref_val <- grid$sleep_weekday[which.min(abs(grid$sleep_weekday - 7))]
# ref_fit <- grid$fit[which.min(abs(grid$sleep_weekday - 7))]
# 
# # Normalize to reference PR
# grid$PR <- grid$fit / ref_fit
# grid$lower <- grid$lower / ref_fit
# grid$upper <- grid$upper / ref_fit
# 
# ```
# 
# 
# ```{r}
# ggplot(grid, aes(x = sleep_weekday, y = PR)) +
#   geom_ribbon(aes(ymin = lower, ymax = upper), fill = "red", alpha = 0.2) +
#   geom_line(color = "red", size = 1) +
#   geom_hline(yintercept = 1, linetype = "dashed", color = "darkcyan") +
#   geom_vline(xintercept = ref_val, linetype = "dashed", color = "darkcyan") +
#   geom_vline(xintercept = breakpoint, linetype = "dotted", color = "blue", size = 1) +
#   annotate("text", x = breakpoint, y = max(grid$upper, na.rm = TRUE) * 0.95,
#            label = paste0("Inflection ≈ ", round(breakpoint, 2), "\n(95% CI: ", 
#                           inflection_CI[1], "–", inflection_CI[2], ")"), 
#            hjust = 0.5, vjust = 1.5, color = "blue", size = 3.5) +
#   geom_histogram(data = complete_data, aes(x = sleep_weekday, y = ..count../sum(..count..)),
#                  fill = "skyblue", color = "skyblue4", bins = 30, inherit.aes = FALSE) +
#   labs(x = "Sleep duration (weekday)", y = "Prevalence Ratio",
#        title = paste0("P for non-linearity: ", signif(pval_nonlin, 3))) +
#   theme_minimal(base_size = 13)
# 
# ```
# 
# 
# 
# ```{r}
# # Load libraries
# library(survey)
# library(splines)
# library(segmented)
# library(boot)
# library(ggplot2)
# library(dplyr)
# 
# # 1. Survey design object
# nhanes_design <- svydesign(
#   ids = ~psu,
#   strata = ~stratum,
#   weights = ~interview_weight,
#   data = complete_data,
#   nest = TRUE
# )
# 
# # 2. Fit spline-based modified Poisson model
# fit_rcs <- svyglm(
#   Obesity ~ ns(sleep_weekday, df = 4) + Age_Group + gender + race_ethnicity +
#     income_ratio + education,
#   design = nhanes_design,
#   family = poisson(link = "log")
# )
# 
# # 3. Fit linear model for comparison
# fit_lm <- svyglm(
#   Obesity ~ sleep_weekday + Age_Group + gender + race_ethnicity +
#     income_ratio + education,
#   design = nhanes_design,
#   family = poisson(link = "log")
# )
# 
# # 4. LRT for non-linearity
# lr_stat <- fit_lm$deviance - fit_rcs$deviance
# df_diff <- fit_lm$df.residual - fit_rcs$df.residual
# pval_nonlin <- pchisq(lr_stat, df = df_diff, lower.tail = FALSE)
# 
# # 5. Estimate breakpoint using unweighted segmented model
# glm_mod <- glm(
#   Obesity ~ sleep_weekday + Age_Group + gender + race_ethnicity +
#     income_ratio + education,
#   data = complete_data,
#   family = poisson(link = "log")
# )
# seg_fit <- segmented(glm_mod, seg.Z = ~ sleep_weekday, npsi = 1)
# breakpoint <- seg_fit$psi[1, "Est."]
# 
# # 6. Bootstrap inflection point
# get_breakpoint <- function(data, indices) {
#   d <- data[indices, ]
#   mod <- glm(Obesity ~ sleep_weekday + Age_Group + gender + race_ethnicity +
#                income_ratio + education, data = d, family = poisson(link = "log"))
#   seg_mod <- tryCatch(segmented(mod, seg.Z = ~ sleep_weekday, npsi = 1),
#                       error = function(e) return(NA))
#   if (is.na(seg_mod)[1]) return(NA)
#   return(seg_mod$psi[1, "Est."])
# }
# set.seed(123)
# boot_out <- boot(data = complete_data, statistic = get_breakpoint, R = 5)
# boot_ci <- boot.ci(boot_out, type = "perc")
# inflection_CI <- round(boot_ci$percent[4:5], 2)
# 
# # 7. Prediction grid: only within observed sleep range
# range_obs <- range(complete_data$sleep_weekday, na.rm = TRUE)
# mean_covariates <- complete_data %>%
#   summarise(across(c(income_ratio), ~mean(.x, na.rm = TRUE))) %>%
#   mutate(Age_Group = "40-61", gender = "Female",
#          race_ethnicity = "Non-Hispanic White", education = "College graduate")
# 
# grid <- data.frame(sleep_weekday = seq(floor(range_obs[1]), ceiling(range_obs[2]), 0.1)) %>%
#   cbind(mean_covariates[rep(1, nrow(.)), ])
# 
# # 8. Predict log PR and compute CIs
# pred_log <- predict(fit_rcs, newdata = grid, type = "link", se.fit = TRUE)
# grid$log_fit <- as.numeric(pred_log)
# grid$se <- sqrt(attr(pred_log, "var"))
# grid$fit <- exp(grid$log_fit)
# grid$lower <- exp(grid$log_fit - 1.96 * grid$se)
# grid$upper <- exp(grid$log_fit + 1.96 * grid$se)
# 
# # 9. Normalize to reference value (median sleep)
# ref_val <- median(complete_data$sleep_weekday, na.rm = TRUE)
# ref_index <- which.min(abs(grid$sleep_weekday - ref_val))
# ref_fit <- grid$fit[ref_index]
# grid$PR <- grid$fit / ref_fit
# grid$lower <- grid$lower / ref_fit
# grid$upper <- grid$upper / ref_fit
# 
# ```
# 
# ```{r}
# ggplot(grid, aes(x = sleep_weekday, y = PR)) +
#   geom_ribbon(aes(ymin = lower, ymax = upper), fill = "red", alpha = 0.2) +
#   geom_line(color = "red", size = 1) +
#   geom_hline(yintercept = 1, linetype = "dashed", color = "darkcyan") +
#   geom_vline(xintercept = ref_val, linetype = "dashed", color = "darkcyan") +
#   geom_vline(xintercept = breakpoint, linetype = "dotted", color = "blue", size = 1) +
#   annotate("text", x = breakpoint, y = max(grid$upper, na.rm = TRUE) * 0.9,
#            label = paste0("Inflection ≈ ", round(breakpoint, 2), "\n(95% CI: ", 
#                           inflection_CI[1], "–", inflection_CI[2], ")"),
#            hjust = 0.5, vjust = 1.5, color = "blue", size = 3.5) +
#   annotate("text", x = min(grid$sleep_weekday) + 0.5,
#            y = max(grid$upper, na.rm = TRUE) * 0.95,
#            label = paste0("P for non-linearity: ", signif(pval_nonlin, 3)),
#            hjust = 0, vjust = 1, size = 4.5, fontface = "bold") +
#   geom_histogram(data = complete_data,
#                  aes(x = sleep_weekday, y = ..count../sum(..count..)),
#                  fill = "skyblue", color = "skyblue4", bins = 30,
#                  inherit.aes = FALSE) +
#   labs(x = "Sleep duration (weekday)",
#        y = "Prevalence Ratio",
#        title = NULL) +
#   theme_minimal(base_size = 13)
# 
# ```
# We evaluated the relationship between weekday sleep duration and obesity using a survey-weighted modified Poisson regression model with restricted cubic splines (4 degrees of freedom). The model adjusted for age group, gender, race/ethnicity, income ratio, education, alcohol intake, physical activity, total energy intake, sugar intake, saturated fat, dyslipidemia, hypertension, depression, and diabetes.
# 
# There was no evidence of a non-linear association between weekday sleep duration and obesity (p for non-linearity = 0.953). The prevalence ratio remained relatively flat across the observed range of sleep duration, and the estimated inflection point at approximately 7.5 hours was not statistically meaningful (95% CI: 5–7.5 hours). These findings suggest weekday sleep duration was not independently associated with obesity in this population after covariate adjustment.
# 
# While some prior studies, including those adjusting for multiple sociodemographic and behavioral factors, have reported a statistically significant non-linear relationship between sleep duration and obesity, our analysis using survey-weighted modified Poisson regression did not replicate this pattern. The divergence in findings may reflect differences in statistical modeling (e.g., odds ratios vs. prevalence ratios), spline specification, and the incorporation of survey design. These findings highlight the need to consider analytic approach when interpreting non-linear associations
# 
# 
# 
# ## WITHOUT SURVEY 
# ```{r}
# library(splines)
# 
# # Poisson regression with RCS
# fit_rcs <- glm(
#   Obesity ~ ns(sleep_weekday, df = 4) + Age_Group + gender +
#     race_ethnicity + income_ratio + education,
#   data = complete_data,
#   family = poisson(link = "log")
# )
# 
# # Linear Poisson model (for LRT)
# fit_lm <- glm(
#   Obesity ~ sleep_weekday + Age_Group + gender +
#     race_ethnicity + income_ratio + education,
#   data = complete_data,
#   family = poisson(link = "log")
# )
# 
# # Likelihood ratio test for non-linearity
# lrt <- anova(fit_lm, fit_rcs, test = "LRT")
# pval_nonlin <- lrt$`Pr(>Chi)`[2]
# library(segmented)
# 
# seg_fit <- segmented(fit_lm, seg.Z = ~ sleep_weekday, npsi = 1)
# breakpoint <- seg_fit$psi[1, "Est."]
# library(boot)
# 
# get_breakpoint <- function(data, indices) {
#   d <- data[indices, ]
#   mod <- glm(
#     Obesity ~ sleep_weekday + Age_Group + gender + race_ethnicity +
#       income_ratio + education,
#     data = d,
#     family = poisson(link = "log")
#   )
#   
#   seg_mod <- tryCatch(segmented(mod, seg.Z = ~ sleep_weekday, npsi = 1),
#                       error = function(e) return(NA))
#   
#   if (is.na(seg_mod)[1]) return(NA)
#   return(seg_mod$psi[1, "Est."])
# }
# 
# set.seed(123)
# boot_out <- boot(data = complete_data, statistic = get_breakpoint, R = 5)
# boot_ci <- boot.ci(boot_out, type = "perc")
# inflection_CI <- round(boot_ci$percent[4:5], 2)
# # Create new data for prediction
# mean_covariates <- complete_data %>%
#   summarise(across(c(income_ratio), ~mean(.x, na.rm = TRUE))) %>%
#   mutate(Age_Group = "40-61", gender = "Female",
#          race_ethnicity = "Non-Hispanic White", education = "College graduate")
# 
# grid <- data.frame(sleep_weekday = seq(3, 11, 0.1)) %>%
#   cbind(mean_covariates[rep(1, nrow(.)), ])
# 
# # Predict log(PR)
# pred_log <- predict(fit_rcs, newdata = grid, type = "link", se.fit = TRUE)
# grid$log_fit <- pred_log$fit
# grid$se <- pred_log$se.fit
# 
# # Convert to PR scale
# grid$fit <- exp(grid$log_fit)
# grid$lower <- exp(grid$log_fit - 1.96 * grid$se)
# grid$upper <- exp(grid$log_fit + 1.96 * grid$se)
# 
# # Normalize to reference (e.g., 7 hours)
# ref_index <- which.min(abs(grid$sleep_weekday - 7))
# ref_val <- grid$sleep_weekday[ref_index]
# ref_fit <- grid$fit[ref_index]
# 
# grid$PR <- grid$fit / ref_fit
# grid$lower <- grid$lower / ref_fit
# grid$upper <- grid$upper / ref_fit
# library(ggplot2)
# 
# ggplot(grid, aes(x = sleep_weekday, y = PR)) +
#   geom_ribbon(aes(ymin = lower, ymax = upper), fill = "red", alpha = 0.2) +
#   geom_line(color = "red", size = 1) +
#   geom_hline(yintercept = 1, linetype = "dashed", color = "darkcyan") +
#   geom_vline(xintercept = ref_val, linetype = "dashed", color = "darkcyan") +
#   geom_vline(xintercept = breakpoint, linetype = "dotted", color = "blue", size = 1) +
#   annotate("text", x = breakpoint, y = max(grid$upper, na.rm = TRUE) * 0.95,
#            label = paste0("Inflection ≈ ", round(breakpoint, 2),
#                           "\n(95% CI: ", inflection_CI[1], "–", inflection_CI[2], ")"),
#            hjust = 0.5, vjust = 1.5, color = "blue", size = 3.5) +
#   geom_histogram(data = complete_data,
#                  aes(x = sleep_weekday, y = ..count../sum(..count..)),
#                  fill = "skyblue", color = "skyblue4", bins = 30, inherit.aes = FALSE) +
#   labs(x = "Sleep duration (weekday)", y = "Prevalence Ratio",
#        title = paste0("P for non-linearity: ", signif(pval_nonlin, 3))) +
#   theme_minimal(base_size = 13)
# 
# ```
# ## using RCS
# ```{r}
# library(rms)        # for rcspline.eval()
# library(dplyr)
# library(boot)
# library(segmented)
# library(ggplot2)
# 
# ```
# 
# ```{r}
# # Create RCS basis with 4 knots → will return 2 terms (4 - 2)
# rcs_terms <- as.data.frame(rcspline.eval(complete_data$sleep_weekday, nk = 4))
# colnames(rcs_terms) <- paste0("rcs", seq_len(ncol(rcs_terms)))
# colnames(rcs_terms) 
# # Combine with dataset
# data_rcs <- cbind(complete_data, rcs_terms)
# 
# 
# ```
# 
# 
# ```{r}
# # Linear model
# fit_linear <- glm(
#   Obesity ~ sleep_weekday + Age_Group + gender + race_ethnicity + income_ratio + education,
#   data = complete_data,
#   family = poisson(link = "log")
# )
# 
# # RCS model (2 spline terms)
# fit_rcs <- glm(
#   Obesity ~ rcs1 + rcs2 + Age_Group + gender + race_ethnicity + income_ratio + education,
#   data = data_rcs,
#   family = poisson(link = "log")
# )
# 
# # Likelihood ratio test for non-linearity
# lrt <- anova(fit_linear, fit_rcs, test = "LRT")
# pval_nonlin <- lrt$`Pr(>Chi)`[2]
# pval_nonlin
# ```
# 
# ```{r}
# seg_fit <- segmented(fit_linear, seg.Z = ~ sleep_weekday, npsi = 1)
# breakpoint <- seg_fit$psi[1, "Est."]
# 
# ```
# 
# 
# ```{r}
# get_breakpoint <- function(data, indices) {
#   d <- data[indices, ]
#   mod <- glm(
#     Obesity ~ sleep_weekday + Age_Group + gender + race_ethnicity + income_ratio + education,
#     data = d,
#     family = poisson(link = "log")
#   )
#   
#   seg_mod <- tryCatch(segmented(mod, seg.Z = ~ sleep_weekday, npsi = 1),
#                       error = function(e) return(NA))
#   if (is.na(seg_mod)[1]) return(NA)
#   return(seg_mod$psi[1, "Est."])
# }
# 
# set.seed(123)
# boot_out <- boot(data = complete_data, statistic = get_breakpoint, R = 5)
# boot_ci <- boot.ci(boot_out, type = "perc")
# inflection_CI <- round(boot_ci$percent[4:5], 2)
# 
# ```
# 
# 
# ```{r}
# # Create grid of sleep values
# grid <- data.frame(sleep_weekday = seq(3, 11, 0.1))
# 
# # Add reference profile
# ref_cov <- complete_data %>%
#   summarise(across(income_ratio, ~mean(.x, na.rm = TRUE))) %>%
#   mutate(Age_Group = "40-61", gender = "Female", race_ethnicity = "Non-Hispanic White", education = "College graduate")
# grid <- cbind(grid, ref_cov[rep(1, nrow(grid)), ])
# 
# # Add RCS terms to grid
# rcs_grid <- as.data.frame(rcspline.eval(grid$sleep_weekday, nk = 4))
# colnames(rcs_grid) <- paste0("rcs", seq_len(ncol(rcs_grid)))
# grid_rcs <- cbind(grid, rcs_grid)
# 
# # Predict log PRs and CI
# pred <- predict(fit_rcs, newdata = grid_rcs, type = "link", se.fit = TRUE)
# grid_rcs$log_fit <- pred$fit
# grid_rcs$se <- pred$se.fit
# 
# # Back-transform to PRs
# grid_rcs$fit <- exp(grid_rcs$log_fit)
# grid_rcs$lower <- exp(grid_rcs$log_fit - 1.96 * grid_rcs$se)
# grid_rcs$upper <- exp(grid_rcs$log_fit + 1.96 * grid_rcs$se)
# 
# # Normalize to 7-hour reference
# ref_index <- which.min(abs(grid_rcs$sleep_weekday - 7))
# ref_val <- grid_rcs$sleep_weekday[ref_index]
# ref_fit <- grid_rcs$fit[ref_index]
# 
# grid_rcs$PR <- grid_rcs$fit / ref_fit
# grid_rcs$lower <- grid_rcs$lower / ref_fit
# grid_rcs$upper <- grid_rcs$upper / ref_fit
# 
# ```
# 
# 
# 
# ```{r}
# ggplot(grid_rcs, aes(x = sleep_weekday, y = PR)) +
#   geom_ribbon(aes(ymin = lower, ymax = upper), fill = "red", alpha = 0.2) +
#   geom_line(color = "red", size = 1) +
#   geom_hline(yintercept = 1, linetype = "dashed", color = "darkcyan") +
#   geom_vline(xintercept = ref_val, linetype = "dashed", color = "darkcyan") +
#   geom_vline(xintercept = breakpoint, linetype = "dotted", color = "blue", size = 1) +
#   annotate("text", x = breakpoint, y = max(grid_rcs$upper, na.rm = TRUE) * 0.95,
#            label = paste0("Inflection ≈ ", round(breakpoint, 2),
#                           "\n(95% CI: ", inflection_CI[1], "–", inflection_CI[2], ")"),
#            hjust = 0.5, vjust = 1.5, color = "blue", size = 3.5) +
#   geom_histogram(data = complete_data,
#                  aes(x = sleep_weekday, y = ..count../sum(..count..)),
#                  fill = "skyblue", color = "skyblue4", bins = 30, inherit.aes = FALSE) +
#   labs(x = "Sleep duration (weekday)", y = "Prevalence Ratio",
#        title = paste0("Restricted Cubic Spline (PR Model)\nP for non-linearity: ", signif(pval_nonlin, 3))) +
#   theme_minimal(base_size = 13)
# 
# ```
# Using restricted cubic splines in a modified Poisson regression model adjusted for sociodemographic factors, we did not observe strong statistical evidence of a non-linear association between weekday sleep duration and obesity (P for non-linearity = 0.213). The estimated inflection point occurred at approximately 7.5 hours of sleep (95% CI: 5–7.5), though the overall curve was relatively flat, and confidence intervals were wide at the tails, reflecting limited data in those ranges.
# 
# 
# 
# 
# 
# 
# ```{r}
# library(survey)
# library(rms)
# library(boot)
# library(dplyr)
# library(ggplot2)
# library(segmented)
# library(Hmisc)  # for rcspline.eval
# 
# ```
# 
# 
# 
# ```{r}
# nhanes_design <- svydesign(
#   ids = ~psu,
#   strata = ~stratum,
#   weights = ~interview_weight,
#   data = complete_data,
#   nest = TRUE
# )
# 
# ```
# 
# 
# 
# ```{r}
# # Create RCS basis with 4 knots
# rcs_basis <- as.data.frame(rcspline.eval(complete_data$sleep_weekday, nk = 4))
# 
# colnames(rcs_basis) <- c("rcs1", "rcs2")
# 
# # Combine with dataset
# complete_data_rcs <- cbind(complete_data, rcs_basis)
# 
# ```
# 
# 
# ```{r}
# nhanes_design_rcs <- svydesign(
#   ids = ~psu,
#   strata = ~stratum,
#   weights = ~interview_weight,
#   data = complete_data_rcs,
#   nest = TRUE
# )
# 
# ```
# 
# 
# ```{r}
# fit_rcs <- svyglm(
#   Obesity ~ rcs1 + rcs2 + Age_Group + gender + race_ethnicity + income_ratio + education,
#   design = nhanes_design_rcs,
#   family = poisson(link = "log")
# )
# 
# fit_linear <- svyglm(
#   Obesity ~ sleep_weekday + Age_Group + gender + race_ethnicity + income_ratio + education,
#   design = nhanes_design_rcs,
#   family = poisson(link = "log")
# )
# 
# ```
# 
# 
# ```{r}
# lrt <- fit_linear$deviance - fit_rcs$deviance
# df_diff <- fit_linear$df.residual - fit_rcs$df.residual
# pval_nonlin <- pchisq(lrt, df_diff, lower.tail = FALSE)
# pval_nonlin
# ```
# ```{r}
# mean_covs <- complete_data_rcs %>%
#   summarise(across(c(income_ratio), mean, na.rm = TRUE)) %>%
#   mutate(
#     Age_Group = "18-39",
#     gender = "Female",
#     race_ethnicity = "Non-Hispanic White",
#     education = "College graduate"
#   )
# 
# grid <- data.frame(sleep_weekday = seq(3, 11, 0.1))
# rcs_grid <- as.data.frame(rcspline.eval(grid$sleep_weekday, nk = 4))
# colnames(rcs_grid) <- c("rcs1", "rcs2")
# grid <- cbind(grid, rcs_grid)
# grid <- cbind(grid, mean_covs[rep(1, nrow(grid)), ])
# 
# ```
# 
# ```{r}
# # Predict log(PR) and extract values correctly
# pred_log <- predict(fit_rcs, newdata = grid, type = "link", se.fit = TRUE)
# 
# # The predicted values
# grid$log_fit <- as.numeric(pred_log)
# 
# # The standard errors
# grid$se <- sqrt(attr(pred_log, "var"))
# 
# 
# grid$fit <- exp(grid$log_fit)
# grid$lower <- exp(grid$log_fit - 1.96 * grid$se)
# grid$upper <- exp(grid$log_fit + 1.96 * grid$se)
# 
# # Normalize to reference (closest to 7)
# ref_idx <- which.min(abs(grid$sleep_weekday - 7))
# ref_fit <- grid$fit[ref_idx]
# 
# grid$PR <- grid$fit / ref_fit
# grid$lower <- grid$lower / ref_fit
# grid$upper <- grid$upper / ref_fit
# 
# ```
# 
# 
# ```{r}
# get_breakpoint <- function(data, indices) {
#   d <- data[indices, ]
#   mod <- glm(Obesity ~ sleep_weekday + Age_Group + gender + race_ethnicity +
#                income_ratio + education,
#              data = d, family = poisson(link = "log"))
#   seg <- tryCatch(segmented(mod, seg.Z = ~ sleep_weekday, npsi = 1), error = function(e) NA)
#   if (is.na(seg)[1]) return(NA)
#   seg$psi[1, "Est."]
# }
# 
# set.seed(123)
# boot_out <- boot(complete_data, get_breakpoint, R = 5)
# boot_ci <- boot.ci(boot_out, type = "perc")
# breakpoint <- boot_out$t0
# inflection_CI <- round(boot_ci$percent[4:5], 2)
# 
# ```
# 
# 
# ```{r}
# ggplot(grid, aes(x = sleep_weekday, y = PR)) +
#   geom_ribbon(aes(ymin = lower, ymax = upper), fill = "red", alpha = 0.2) +
#   geom_line(color = "red", size = 1) +
#   geom_hline(yintercept = 1, linetype = "dashed", color = "darkcyan") +
#   geom_vline(xintercept = 7, linetype = "dashed", color = "darkcyan") +
#   geom_vline(xintercept = breakpoint, linetype = "dotted", color = "blue", size = 1) +
#   annotate("text", x = breakpoint, y = max(grid$upper, na.rm = TRUE) * 0.9,
#            label = paste0("Inflection ≈ ", round(breakpoint, 1), "\n(95% CI: ", 
#                           inflection_CI[1], "–", inflection_CI[2], ")"),
#            color = "blue", size = 3.5) +
#   geom_histogram(data = complete_data, aes(x = sleep_weekday, y = ..count../sum(..count..)),
#                  fill = "skyblue", color = "skyblue4", bins = 30, inherit.aes = FALSE) +
#   labs(
#     title = "Restricted Cubic Spline (PR Model)",
#     subtitle = paste0("P for non-linearity: ", signif(pval_nonlin, 3)),
#     x = "Sleep duration (weekday)",
#     y = "Prevalence Ratio"
#   ) +
#   theme_minimal(base_size = 13)
# 
# ```
# 
# 
# ## Imputation
# 
# 
# ```{r}
# mice_nhanes$Obesity <- ifelse(mice_nhanes$Obesity == "Yes", 1, 0)
# imp_init <- mice(mice_nhanes, maxit = 0, print = FALSE)
# pred     <- imp_init$pred
# meth     <- imp_init$meth     # a named vector of length ncol(data)
# 
# 
# # Zero‐out predictors for these variables
# for (v in c("SEQN","psu","stratum","interview_weight")) {
#   meth[v] <- ""               # do not impute
#   pred[,v] <- pred[v,] <- 0   # do not use as predictor
# }
# 
# # Continuous with predictive mean matching
# for (v in c("sat_fat","sugar","energy_kcal","sleep_weekend","income_ratio")) {
#   meth[v] <- "pmm"
# }
# 
# # Binary logistic
# for (v in c("hypertension","diabetes","dyslipidemia","alcohol_cat","physically_active")) {
#   meth[v] <- "logreg"
# }
# 
# # Polytomous logistic
# for (v in c("snore","apnea_symptoms","education","daytime_sleepy", "depression")) {
#   meth[v] <- "polyreg"
# }
# 
# imputation <- mice(
#   data            = mice_nhanes,
#   predictorMatrix = pred,
#   method          = meth,
#   m               = 2,    
#   maxit           = 10,
#   seed            = 123,
#   printFlag       = FALSE
# )
# ```
# 
# ```{r}
# library(mice)
# imp_long <- complete(imputation, action = "long", include = TRUE)
# 
# ```
# 
# ```{r}
# library(dplyr)
# library(Hmisc)
# 
# imp_long_rcs <- imp_long %>%
#   group_by(.imp) %>%
#   group_modify(~ {
#     rcs <- as.data.frame(rcspline.eval(.x$sleep_weekday, nk = 4))
#     colnames(rcs) <- c("rcs1", "rcs2")
#     bind_cols(.x, rcs)
#   }) %>%
#   ungroup()
# 
# 
# ```
# 
# ```{r}
# imp_list <- lapply(split(imp_long_rcs, imp_long_rcs$.imp), function(df) {
#   svydesign(ids = ~psu, strata = ~stratum, weights = ~interview_weight,
#             data = df, nest = TRUE)
# })
# allImputations <- imputationList(imp_list)
# 
# 
# ```
# 
# ```{r}
# models_rcs <- with(allImputations, svyglm(
#   Obesity ~ rcs1 + rcs2 + Age_Group + gender + race_ethnicity + income_ratio + education,
#   family = poisson(link = "log")
# ))
# 
# models_linear <- with(allImputations, svyglm(
#   Obesity ~ sleep_weekday + Age_Group + gender + race_ethnicity + income_ratio + education,
#   family = poisson(link = "log")
# ))
# 
# ```
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# ```{r}
# # Load libraries
# library(survey)
# library(splines)
# library(segmented)
# library(boot)
# library(ggplot2)
# library(dplyr)
# 
# # 1. Survey design object
# nhanes_design <- svydesign(
#   ids = ~psu,
#   strata = ~stratum,
#   weights = ~interview_weight,
#   data = complete_data,
#   nest = TRUE
# )
# 
# # 2. Full covariate list
# covariates <- ~ Age_Group + gender + race_ethnicity + income_ratio + education +
#   alcohol_cat + physically_active + energy_kcal + sugar + sat_fat +
#   dyslipidemia + hypertension + depression + diabetes
# 
# # 3. Fit spline-based modified Poisson model
# fit_rcs <- svyglm(
#   update(Obesity ~ ns(sleep_weekday, df = 4), covariates),
#   design = nhanes_design,
#   family = poisson(link = "log")
# )
# 
# # 4. Fit linear model (no spline) for LRT comparison
# fit_lm <- svyglm(
#   update(Obesity ~ sleep_weekday, covariates),
#   design = nhanes_design,
#   family = poisson(link = "log")
# )
# 
# # 5. LRT for non-linearity
# lr_stat <- fit_lm$deviance - fit_rcs$deviance
# df_diff <- fit_lm$df.residual - fit_rcs$df.residual
# pval_nonlin <- pchisq(lr_stat, df = df_diff, lower.tail = FALSE)
# 
# # 6. Estimate breakpoint using unweighted model
# glm_mod <- glm(
#   update(Obesity ~ sleep_weekday, covariates),
#   data = complete_data,
#   family = poisson(link = "log")
# )
# seg_fit <- segmented(glm_mod, seg.Z = ~ sleep_weekday, npsi = 1)
# breakpoint <- seg_fit$psi[1, "Est."]
# 
# # 7. Bootstrap breakpoint
# get_breakpoint <- function(data, indices) {
#   d <- data[indices, ]
#   mod <- glm(update(Obesity ~ sleep_weekday, covariates),
#              data = d, family = poisson(link = "log"))
#   seg_mod <- tryCatch(segmented(mod, seg.Z = ~ sleep_weekday, npsi = 1),
#                       error = function(e) return(NA))
#   if (is.na(seg_mod)[1]) return(NA)
#   return(seg_mod$psi[1, "Est."])
# }
# set.seed(123)
# boot_out <- boot(data = complete_data, statistic = get_breakpoint, R = 5)
# boot_ci <- boot.ci(boot_out, type = "perc")
# inflection_CI <- round(boot_ci$percent[4:5], 2)
# 
# ```
# 
# ```{r}
# # 8. Covariate values for prediction (reference or average values)
# mean_covariates <- complete_data %>%
#   summarise(across(c(income_ratio, energy_kcal, sugar, sat_fat), ~mean(.x, na.rm = TRUE))) %>%
#   mutate(Age_Group = "40-61", gender = "Female", race_ethnicity = "Non-Hispanic White",
#          education = "College graduate", alcohol_cat = "1–2/day",
#          physically_active = "Yes", dyslipidemia = "No",
#          hypertension = "No", depression = "None", diabetes = "Not Diabetic")
# 
# # 9. Restrict prediction grid to observed range
# range_obs <- range(complete_data$sleep_weekday, na.rm = TRUE)
# grid <- data.frame(sleep_weekday = seq(floor(range_obs[1]), ceiling(range_obs[2]), 0.1)) %>%
#   cbind(mean_covariates[rep(1, nrow(.)), ])
# 
# # 10. Predict log PR and compute CI
# pred_log <- predict(fit_rcs, newdata = grid, type = "link", se.fit = TRUE)
# grid$log_fit <- as.numeric(pred_log)
# grid$se <- sqrt(attr(pred_log, "var"))
# 
# grid$fit <- exp(grid$log_fit)
# grid$lower <- exp(grid$log_fit - 1.96 * grid$se)
# grid$upper <- exp(grid$log_fit + 1.96 * grid$se)
# 
# # 11. Normalize to median sleep
# ref_val <- median(complete_data$sleep_weekday, na.rm = TRUE)
# ref_index <- which.min(abs(grid$sleep_weekday - ref_val))
# ref_fit <- grid$fit[ref_index]
# 
# grid$PR <- grid$fit / ref_fit
# grid$lower <- grid$lower / ref_fit
# grid$upper <- grid$upper / ref_fit
# 
# ```
# 
# ```{r}
# ggplot(grid, aes(x = sleep_weekday, y = PR)) +
#   geom_ribbon(aes(ymin = lower, ymax = upper), fill = "red", alpha = 0.2) +
#   geom_line(color = "red", size = 1) +
#   geom_hline(yintercept = 1, linetype = "dashed", color = "darkcyan") +
#   geom_vline(xintercept = ref_val, linetype = "dashed", color = "darkcyan") +
#   geom_vline(xintercept = breakpoint, linetype = "dotted", color = "blue", size = 1) +
#   annotate("text", x = breakpoint, y = max(grid$upper, na.rm = TRUE) * 0.9,
#            label = paste0("Inflection ≈ ", round(breakpoint, 2),
#                           "\n(95% CI: ", inflection_CI[1], "–", inflection_CI[2], ")"),
#            hjust = 0.5, vjust = 1.5, color = "blue", size = 3.5) +
#   annotate("text", x = min(grid$sleep_weekday) + 0.5,
#            y = max(grid$upper, na.rm = TRUE) * 0.95,
#            label = paste0("P for non-linearity: ", signif(pval_nonlin, 3)),
#            hjust = 0, vjust = 1, size = 4.5, fontface = "bold") +
#   geom_histogram(data = complete_data,
#                  aes(x = sleep_weekday, y = ..count../sum(..count..)),
#                  fill = "skyblue", color = "skyblue4", bins = 30, inherit.aes = FALSE) +
#   labs(x = "Sleep duration (weekday)", y = "Prevalence Ratio") +
#   coord_cartesian(ylim = c(0, min(5, max(grid$upper, na.rm = TRUE)))) +
#   theme_minimal(base_size = 13)


```












































